(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[3],{

/***/ "../node_modules/@aws-amplify/ui-components/dist/esm-es5/amplify-radio-button_2.entry.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@aws-amplify/ui-components/dist/esm-es5/amplify-radio-button_2.entry.js ***!
  \***********************************************************************************************/
/*! exports provided: amplify_radio_button, amplify_totp_setup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"amplify_radio_button\", function() { return AmplifyRadioButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"amplify_totp_setup\", function() { return AmplifyTOTPSetup; });\n/* harmony import */ var _index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-3fb5c139.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/index-3fb5c139.js\");\n/* harmony import */ var _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aws-amplify/core */ \"../node_modules/@aws-amplify/core/lib-esm/index.js\");\n/* harmony import */ var _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./auth-types-78df304e.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/auth-types-78df304e.js\");\n/* harmony import */ var _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aws-amplify/auth */ \"../node_modules/@aws-amplify/auth/lib-esm/index.js\");\n/* harmony import */ var _Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Translations-c833f663.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/Translations-c833f663.js\");\n/* harmony import */ var _constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants-d1abe7de.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/constants-d1abe7de.js\");\n/* harmony import */ var _helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers-09e7c279.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/helpers-09e7c279.js\");\n/* harmony import */ var _auth_helpers_63cc23c0_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./auth-helpers-63cc23c0.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/auth-helpers-63cc23c0.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! buffer */ \"../node_modules/buffer/index.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_8__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n\n\nvar amplifyRadioButtonCss = \":host{--font-family:var(--amplify-font-family)}.radio-button{display:block;width:100%;padding:16px;font-size:var(--amplify-text-sm);font-family:var(--font-family)}.radio-button input{margin-right:12px}\";\nvar AmplifyRadioButton = /** @class */ (function () {\n    function AmplifyRadioButton(hostRef) {\n        Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"r\"])(this, hostRef);\n        /** (Optional) The placeholder for the input element.  Using hints is recommended, but placeholders can also be useful to convey information to users. */\n        this.placeholder = '';\n        /** If `true`, the radio button is selected. */\n        this.checked = false;\n        /** If `true`, the checkbox is disabled */\n        this.disabled = false;\n    }\n    AmplifyRadioButton.prototype.render = function () {\n        return (Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"span\", { class: \"radio-button\" }, Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"input\", Object.assign({ type: \"radio\", name: this.name, value: this.value, onInput: this.handleInputChange, placeholder: this.placeholder, id: this.fieldId, checked: this.checked, disabled: this.disabled }, this.inputProps)), Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"amplify-label\", { htmlFor: this.fieldId }, this.label)));\n    };\n    return AmplifyRadioButton;\n}());\nAmplifyRadioButton.style = amplifyRadioButtonCss;\n// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\nvar canPromise = function () {\n    return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;\n};\nvar toString = {}.toString;\nvar isarray = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n};\nfunction typedArraySupport() {\n    // Can typed array instances be augmented?\n    try {\n        var arr = new Uint8Array(1);\n        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };\n        return arr.foo() === 42;\n    }\n    catch (e) {\n        return false;\n    }\n}\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\nvar K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff;\nfunction Buffer(arg, offset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, offset, length);\n    }\n    if (typeof arg === 'number') {\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, offset, length);\n}\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    if (typeof Symbol !== 'undefined' && Symbol.species &&\n        Buffer[Symbol.species] === Buffer) {\n        Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true,\n            enumerable: false,\n            writable: false\n        });\n    }\n}\nfunction checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= K_MAX_LENGTH) {\n        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n    }\n    return length | 0;\n}\nfunction isnan(val) {\n    return val !== val; // eslint-disable-line no-self-compare\n}\nfunction createBuffer(that, length) {\n    var buf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        buf = new Uint8Array(length);\n        buf.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        buf = that;\n        if (buf === null) {\n            buf = new Buffer(length);\n        }\n        buf.length = length;\n    }\n    return buf;\n}\nfunction allocUnsafe(that, size) {\n    var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            buf[i] = 0;\n        }\n    }\n    return buf;\n}\nfunction fromString(that, string) {\n    var length = byteLength(string) | 0;\n    var buf = createBuffer(that, length);\n    var actual = buf.write(string);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        buf = buf.slice(0, actual);\n    }\n    return buf;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(that, length);\n    for (var i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n    }\n    return buf;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\\'length\\' is out of bounds');\n    }\n    var buf;\n    if (byteOffset === undefined && length === undefined) {\n        buf = new Uint8Array(array);\n    }\n    else if (length === undefined) {\n        buf = new Uint8Array(array, byteOffset);\n    }\n    else {\n        buf = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        buf.__proto__ = Buffer.prototype;\n    }\n    else {\n        // Fallback: Return an object instance of the Buffer class\n        buf = fromArrayLike(that, buf);\n    }\n    return buf;\n}\nfunction fromObject(that, obj) {\n    if (Buffer.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        var buf = createBuffer(that, len);\n        if (buf.length === 0) {\n            return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj) {\n        if ((typeof ArrayBuffer !== 'undefined' &&\n            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1)\n                        bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1)\n                    bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        }\n        else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1)\n                bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0)\n                break;\n            bytes.push(codePoint);\n        }\n        else if (codePoint < 0x800) {\n            if ((units -= 2) < 0)\n                break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0)\n                break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0)\n                break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        }\n        else {\n            throw new Error('Invalid code point');\n        }\n    }\n    return bytes;\n}\nfunction byteLength(string) {\n    if (Buffer.isBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== 'string') {\n        string = '' + string;\n    }\n    var len = string.length;\n    if (len === 0)\n        return 0;\n    return utf8ToBytes(string).length;\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if ((i + offset >= dst.length) || (i >= src.length))\n            break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction from(that, value, offset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, offset, length);\n    }\n    if (typeof value === 'string') {\n        return fromString(that, value);\n    }\n    return fromObject(that, value);\n}\nBuffer.prototype.write = function write(string, offset, length) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, encoding)\n    }\n    else if (length === undefined && typeof offset === 'string') {\n        length = this.length;\n        offset = 0;\n        // Buffer#write(string, offset[, length])\n    }\n    else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n        }\n        else {\n            length = undefined;\n        }\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n        length = remaining;\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n        throw new RangeError('Attempt to write outside buffer bounds');\n    }\n    return utf8Write(this, string, offset, length);\n};\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0)\n            start = 0;\n    }\n    else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0)\n            end = 0;\n    }\n    else if (end > len) {\n        end = len;\n    }\n    if (end < start)\n        end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        // Return an augmented `Uint8Array` instance\n        newBuf.__proto__ = Buffer.prototype;\n    }\n    else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start)\n        start = 0;\n    if (!end && end !== 0)\n        end = this.length;\n    if (targetStart >= target.length)\n        targetStart = target.length;\n    if (!targetStart)\n        targetStart = 0;\n    if (end > 0 && end < start)\n        end = start;\n    // Copy 0 bytes; we're done\n    if (end === start)\n        return 0;\n    if (target.length === 0 || this.length === 0)\n        return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds');\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds');\n    if (end < 0)\n        throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length)\n        end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start];\n        }\n    }\n    else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\nBuffer.prototype.fill = function fill(val, start, end) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            start = 0;\n            end = this.length;\n        }\n        else if (typeof end === 'string') {\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n    }\n    else if (typeof val === 'number') {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index');\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val)\n        val = 0;\n    var i;\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val;\n        }\n    }\n    else {\n        var bytes = Buffer.isBuffer(val)\n            ? val\n            : new Buffer(val);\n        var len = bytes.length;\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\nBuffer.concat = function concat(list, length) {\n    if (!isarray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return createBuffer(null, 0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n        }\n    }\n    var buffer = allocUnsafe(null, length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nBuffer.byteLength = byteLength;\nBuffer.prototype._isBuffer = true;\nBuffer.isBuffer = function isBuffer(b) {\n    return !!(b != null && b._isBuffer);\n};\nvar alloc = function (size) {\n    var buffer = new Buffer(size);\n    buffer.fill(0);\n    return buffer;\n};\nvar from_1 = function (data) {\n    return new Buffer(data);\n};\nvar typedarrayBuffer = {\n    alloc: alloc,\n    from: from_1\n};\nvar toSJISFunction;\nvar CODEWORDS_COUNT = [\n    0,\n    26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n    2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n];\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nvar getSymbolSize = function getSymbolSize(version) {\n    if (!version)\n        throw new Error('\"version\" cannot be null or undefined');\n    if (version < 1 || version > 40)\n        throw new Error('\"version\" should be in range from 1 to 40');\n    return version * 4 + 17;\n};\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nvar getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n    return CODEWORDS_COUNT[version];\n};\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nvar getBCHDigit = function (data) {\n    var digit = 0;\n    while (data !== 0) {\n        digit++;\n        data >>>= 1;\n    }\n    return digit;\n};\nvar setToSJISFunction = function setToSJISFunction(f) {\n    if (typeof f !== 'function') {\n        throw new Error('\"toSJISFunc\" is not a valid function.');\n    }\n    toSJISFunction = f;\n};\nvar isKanjiModeEnabled = function () {\n    return typeof toSJISFunction !== 'undefined';\n};\nvar toSJIS = function toSJIS(kanji) {\n    return toSJISFunction(kanji);\n};\nvar utils = {\n    getSymbolSize: getSymbolSize,\n    getSymbolTotalCodewords: getSymbolTotalCodewords,\n    getBCHDigit: getBCHDigit,\n    setToSJISFunction: setToSJISFunction,\n    isKanjiModeEnabled: isKanjiModeEnabled,\n    toSJIS: toSJIS\n};\nfunction createCommonjsModule(fn, basedir, module) {\n    return module = {\n        path: basedir,\n        exports: {},\n        require: function (path, base) {\n            return commonjsRequire();\n        }\n    }, fn(module, module.exports), module.exports;\n}\nfunction commonjsRequire() {\n    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\nvar errorCorrectionLevel = createCommonjsModule(function (module, exports) {\n    exports.L = { bit: 1 };\n    exports.M = { bit: 0 };\n    exports.Q = { bit: 3 };\n    exports.H = { bit: 2 };\n    function fromString(string) {\n        if (typeof string !== 'string') {\n            throw new Error('Param is not a string');\n        }\n        var lcStr = string.toLowerCase();\n        switch (lcStr) {\n            case 'l':\n            case 'low':\n                return exports.L;\n            case 'm':\n            case 'medium':\n                return exports.M;\n            case 'q':\n            case 'quartile':\n                return exports.Q;\n            case 'h':\n            case 'high':\n                return exports.H;\n            default:\n                throw new Error('Unknown EC Level: ' + string);\n        }\n    }\n    exports.isValid = function isValid(level) {\n        return level && typeof level.bit !== 'undefined' &&\n            level.bit >= 0 && level.bit < 4;\n    };\n    exports.from = function from(value, defaultValue) {\n        if (exports.isValid(value)) {\n            return value;\n        }\n        try {\n            return fromString(value);\n        }\n        catch (e) {\n            return defaultValue;\n        }\n    };\n});\nfunction BitBuffer() {\n    this.buffer = [];\n    this.length = 0;\n}\nBitBuffer.prototype = {\n    get: function (index) {\n        var bufIndex = Math.floor(index / 8);\n        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;\n    },\n    put: function (num, length) {\n        for (var i = 0; i < length; i++) {\n            this.putBit(((num >>> (length - i - 1)) & 1) === 1);\n        }\n    },\n    getLengthInBits: function () {\n        return this.length;\n    },\n    putBit: function (bit) {\n        var bufIndex = Math.floor(this.length / 8);\n        if (this.buffer.length <= bufIndex) {\n            this.buffer.push(0);\n        }\n        if (bit) {\n            this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));\n        }\n        this.length++;\n    }\n};\nvar bitBuffer = BitBuffer;\n/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix(size) {\n    if (!size || size < 1) {\n        throw new Error('BitMatrix size must be defined and greater than 0');\n    }\n    this.size = size;\n    this.data = typedarrayBuffer.alloc(size * size);\n    this.reservedBit = typedarrayBuffer.alloc(size * size);\n}\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n    var index = row * this.size + col;\n    this.data[index] = value;\n    if (reserved)\n        this.reservedBit[index] = true;\n};\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n    return this.data[row * this.size + col];\n};\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n    this.data[row * this.size + col] ^= value;\n};\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n    return this.reservedBit[row * this.size + col];\n};\nvar bitMatrix = BitMatrix;\nvar alignmentPattern = createCommonjsModule(function (module, exports) {\n    /**\n     * Alignment pattern are fixed reference pattern in defined positions\n     * in a matrix symbology, which enables the decode software to re-synchronise\n     * the coordinate mapping of the image modules in the event of moderate amounts\n     * of distortion of the image.\n     *\n     * Alignment patterns are present only in QR Code symbols of version 2 or larger\n     * and their number depends on the symbol version.\n     */\n    var getSymbolSize = utils.getSymbolSize;\n    /**\n     * Calculate the row/column coordinates of the center module of each alignment pattern\n     * for the specified QR Code version.\n     *\n     * The alignment patterns are positioned symmetrically on either side of the diagonal\n     * running from the top left corner of the symbol to the bottom right corner.\n     *\n     * Since positions are simmetrical only half of the coordinates are returned.\n     * Each item of the array will represent in turn the x and y coordinate.\n     * @see {@link getPositions}\n     *\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of coordinate\n     */\n    exports.getRowColCoords = function getRowColCoords(version) {\n        if (version === 1)\n            return [];\n        var posCount = Math.floor(version / 7) + 2;\n        var size = getSymbolSize(version);\n        var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n        var positions = [size - 7]; // Last coord is always (size - 7)\n        for (var i = 1; i < posCount - 1; i++) {\n            positions[i] = positions[i - 1] - intervals;\n        }\n        positions.push(6); // First coord is always 6\n        return positions.reverse();\n    };\n    /**\n     * Returns an array containing the positions of each alignment pattern.\n     * Each array's element represent the center point of the pattern as (x, y) coordinates\n     *\n     * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n     * and filtering out the items that overlaps with finder pattern\n     *\n     * @example\n     * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n     * The alignment patterns, therefore, are to be centered on (row, column)\n     * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n     * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n     * and are not therefore used for alignment patterns.\n     *\n     * var pos = getPositions(7)\n     * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n     *\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of coordinates\n     */\n    exports.getPositions = function getPositions(version) {\n        var coords = [];\n        var pos = exports.getRowColCoords(version);\n        var posLength = pos.length;\n        for (var i = 0; i < posLength; i++) {\n            for (var j = 0; j < posLength; j++) {\n                // Skip if position is occupied by finder patterns\n                if ((i === 0 && j === 0) || // top-left\n                    (i === 0 && j === posLength - 1) || // bottom-left\n                    (i === posLength - 1 && j === 0)) { // top-right\n                    continue;\n                }\n                coords.push([pos[i], pos[j]]);\n            }\n        }\n        return coords;\n    };\n});\nvar getSymbolSize$1 = utils.getSymbolSize;\nvar FINDER_PATTERN_SIZE = 7;\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nvar getPositions = function getPositions(version) {\n    var size = getSymbolSize$1(version);\n    return [\n        // top-left\n        [0, 0],\n        // top-right\n        [size - FINDER_PATTERN_SIZE, 0],\n        // bottom-left\n        [0, size - FINDER_PATTERN_SIZE]\n    ];\n};\nvar finderPattern = {\n    getPositions: getPositions\n};\nvar maskPattern = createCommonjsModule(function (module, exports) {\n    /**\n     * Data mask pattern reference\n     * @type {Object}\n     */\n    exports.Patterns = {\n        PATTERN000: 0,\n        PATTERN001: 1,\n        PATTERN010: 2,\n        PATTERN011: 3,\n        PATTERN100: 4,\n        PATTERN101: 5,\n        PATTERN110: 6,\n        PATTERN111: 7\n    };\n    /**\n     * Weighted penalty scores for the undesirable features\n     * @type {Object}\n     */\n    var PenaltyScores = {\n        N1: 3,\n        N2: 3,\n        N3: 40,\n        N4: 10\n    };\n    /**\n     * Check if mask pattern value is valid\n     *\n     * @param  {Number}  mask    Mask pattern\n     * @return {Boolean}         true if valid, false otherwise\n     */\n    exports.isValid = function isValid(mask) {\n        return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n    };\n    /**\n     * Returns mask pattern from a value.\n     * If value is not valid, returns undefined\n     *\n     * @param  {Number|String} value        Mask pattern value\n     * @return {Number}                     Valid mask pattern or undefined\n     */\n    exports.from = function from(value) {\n        return exports.isValid(value) ? parseInt(value, 10) : undefined;\n    };\n    /**\n    * Find adjacent modules in row/column with the same color\n    * and assign a penalty value.\n    *\n    * Points: N1 + i\n    * i is the amount by which the number of adjacent modules of the same color exceeds 5\n    */\n    exports.getPenaltyN1 = function getPenaltyN1(data) {\n        var size = data.size;\n        var points = 0;\n        var sameCountCol = 0;\n        var sameCountRow = 0;\n        var lastCol = null;\n        var lastRow = null;\n        for (var row = 0; row < size; row++) {\n            sameCountCol = sameCountRow = 0;\n            lastCol = lastRow = null;\n            for (var col = 0; col < size; col++) {\n                var module = data.get(row, col);\n                if (module === lastCol) {\n                    sameCountCol++;\n                }\n                else {\n                    if (sameCountCol >= 5)\n                        points += PenaltyScores.N1 + (sameCountCol - 5);\n                    lastCol = module;\n                    sameCountCol = 1;\n                }\n                module = data.get(col, row);\n                if (module === lastRow) {\n                    sameCountRow++;\n                }\n                else {\n                    if (sameCountRow >= 5)\n                        points += PenaltyScores.N1 + (sameCountRow - 5);\n                    lastRow = module;\n                    sameCountRow = 1;\n                }\n            }\n            if (sameCountCol >= 5)\n                points += PenaltyScores.N1 + (sameCountCol - 5);\n            if (sameCountRow >= 5)\n                points += PenaltyScores.N1 + (sameCountRow - 5);\n        }\n        return points;\n    };\n    /**\n     * Find 2x2 blocks with the same color and assign a penalty value\n     *\n     * Points: N2 * (m - 1) * (n - 1)\n     */\n    exports.getPenaltyN2 = function getPenaltyN2(data) {\n        var size = data.size;\n        var points = 0;\n        for (var row = 0; row < size - 1; row++) {\n            for (var col = 0; col < size - 1; col++) {\n                var last = data.get(row, col) +\n                    data.get(row, col + 1) +\n                    data.get(row + 1, col) +\n                    data.get(row + 1, col + 1);\n                if (last === 4 || last === 0)\n                    points++;\n            }\n        }\n        return points * PenaltyScores.N2;\n    };\n    /**\n     * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n     * preceded or followed by light area 4 modules wide\n     *\n     * Points: N3 * number of pattern found\n     */\n    exports.getPenaltyN3 = function getPenaltyN3(data) {\n        var size = data.size;\n        var points = 0;\n        var bitsCol = 0;\n        var bitsRow = 0;\n        for (var row = 0; row < size; row++) {\n            bitsCol = bitsRow = 0;\n            for (var col = 0; col < size; col++) {\n                bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);\n                if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D))\n                    points++;\n                bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);\n                if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D))\n                    points++;\n            }\n        }\n        return points * PenaltyScores.N3;\n    };\n    /**\n     * Calculate proportion of dark modules in entire symbol\n     *\n     * Points: N4 * k\n     *\n     * k is the rating of the deviation of the proportion of dark modules\n     * in the symbol from 50% in steps of 5%\n     */\n    exports.getPenaltyN4 = function getPenaltyN4(data) {\n        var darkCount = 0;\n        var modulesCount = data.data.length;\n        for (var i = 0; i < modulesCount; i++)\n            darkCount += data.data[i];\n        var k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);\n        return k * PenaltyScores.N4;\n    };\n    /**\n     * Return mask value at given position\n     *\n     * @param  {Number} maskPattern Pattern reference value\n     * @param  {Number} i           Row\n     * @param  {Number} j           Column\n     * @return {Boolean}            Mask value\n     */\n    function getMaskAt(maskPattern, i, j) {\n        switch (maskPattern) {\n            case exports.Patterns.PATTERN000: return (i + j) % 2 === 0;\n            case exports.Patterns.PATTERN001: return i % 2 === 0;\n            case exports.Patterns.PATTERN010: return j % 3 === 0;\n            case exports.Patterns.PATTERN011: return (i + j) % 3 === 0;\n            case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n            case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0;\n            case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0;\n            case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0;\n            default: throw new Error('bad maskPattern:' + maskPattern);\n        }\n    }\n    /**\n     * Apply a mask pattern to a BitMatrix\n     *\n     * @param  {Number}    pattern Pattern reference number\n     * @param  {BitMatrix} data    BitMatrix data\n     */\n    exports.applyMask = function applyMask(pattern, data) {\n        var size = data.size;\n        for (var col = 0; col < size; col++) {\n            for (var row = 0; row < size; row++) {\n                if (data.isReserved(row, col))\n                    continue;\n                data.xor(row, col, getMaskAt(pattern, row, col));\n            }\n        }\n    };\n    /**\n     * Returns the best mask pattern for data\n     *\n     * @param  {BitMatrix} data\n     * @return {Number} Mask pattern reference number\n     */\n    exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n        var numPatterns = Object.keys(exports.Patterns).length;\n        var bestPattern = 0;\n        var lowerPenalty = Infinity;\n        for (var p = 0; p < numPatterns; p++) {\n            setupFormatFunc(p);\n            exports.applyMask(p, data);\n            // Calculate penalty\n            var penalty = exports.getPenaltyN1(data) +\n                exports.getPenaltyN2(data) +\n                exports.getPenaltyN3(data) +\n                exports.getPenaltyN4(data);\n            // Undo previously applied mask\n            exports.applyMask(p, data);\n            if (penalty < lowerPenalty) {\n                lowerPenalty = penalty;\n                bestPattern = p;\n            }\n        }\n        return bestPattern;\n    };\n});\nvar EC_BLOCKS_TABLE = [\n    // L  M  Q  H\n    1, 1, 1, 1,\n    1, 1, 1, 1,\n    1, 1, 2, 2,\n    1, 2, 2, 4,\n    1, 2, 4, 4,\n    2, 4, 4, 4,\n    2, 4, 6, 5,\n    2, 4, 6, 6,\n    2, 5, 8, 8,\n    4, 5, 8, 8,\n    4, 5, 8, 11,\n    4, 8, 10, 11,\n    4, 9, 12, 16,\n    4, 9, 16, 16,\n    6, 10, 12, 18,\n    6, 10, 17, 16,\n    6, 11, 16, 19,\n    6, 13, 18, 21,\n    7, 14, 21, 25,\n    8, 16, 20, 25,\n    8, 17, 23, 25,\n    9, 17, 23, 34,\n    9, 18, 25, 30,\n    10, 20, 27, 32,\n    12, 21, 29, 35,\n    12, 23, 34, 37,\n    12, 25, 34, 40,\n    13, 26, 35, 42,\n    14, 28, 38, 45,\n    15, 29, 40, 48,\n    16, 31, 43, 51,\n    17, 33, 45, 54,\n    18, 35, 48, 57,\n    19, 37, 51, 60,\n    19, 38, 53, 63,\n    20, 40, 56, 66,\n    21, 43, 59, 70,\n    22, 45, 62, 74,\n    24, 47, 65, 77,\n    25, 49, 68, 81\n];\nvar EC_CODEWORDS_TABLE = [\n    // L  M  Q  H\n    7, 10, 13, 17,\n    10, 16, 22, 28,\n    15, 26, 36, 44,\n    20, 36, 52, 64,\n    26, 48, 72, 88,\n    36, 64, 96, 112,\n    40, 72, 108, 130,\n    48, 88, 132, 156,\n    60, 110, 160, 192,\n    72, 130, 192, 224,\n    80, 150, 224, 264,\n    96, 176, 260, 308,\n    104, 198, 288, 352,\n    120, 216, 320, 384,\n    132, 240, 360, 432,\n    144, 280, 408, 480,\n    168, 308, 448, 532,\n    180, 338, 504, 588,\n    196, 364, 546, 650,\n    224, 416, 600, 700,\n    224, 442, 644, 750,\n    252, 476, 690, 816,\n    270, 504, 750, 900,\n    300, 560, 810, 960,\n    312, 588, 870, 1050,\n    336, 644, 952, 1110,\n    360, 700, 1020, 1200,\n    390, 728, 1050, 1260,\n    420, 784, 1140, 1350,\n    450, 812, 1200, 1440,\n    480, 868, 1290, 1530,\n    510, 924, 1350, 1620,\n    540, 980, 1440, 1710,\n    570, 1036, 1530, 1800,\n    570, 1064, 1590, 1890,\n    600, 1120, 1680, 1980,\n    630, 1204, 1770, 2100,\n    660, 1260, 1860, 2220,\n    720, 1316, 1950, 2310,\n    750, 1372, 2040, 2430\n];\n/**\n * Returns the number of error correction block that the QR Code should contain\n * for the specified version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction blocks\n */\nvar getBlocksCount = function getBlocksCount(version, errorCorrectionLevel$1) {\n    switch (errorCorrectionLevel$1) {\n        case errorCorrectionLevel.L:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n        case errorCorrectionLevel.M:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n        case errorCorrectionLevel.Q:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n        case errorCorrectionLevel.H:\n            return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n        default:\n            return undefined;\n    }\n};\n/**\n * Returns the number of error correction codewords to use for the specified\n * version and error correction level.\n *\n * @param  {Number} version              QR Code version\n * @param  {Number} errorCorrectionLevel Error correction level\n * @return {Number}                      Number of error correction codewords\n */\nvar getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel$1) {\n    switch (errorCorrectionLevel$1) {\n        case errorCorrectionLevel.L:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n        case errorCorrectionLevel.M:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n        case errorCorrectionLevel.Q:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n        case errorCorrectionLevel.H:\n            return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n        default:\n            return undefined;\n    }\n};\nvar errorCorrectionCode = {\n    getBlocksCount: getBlocksCount,\n    getTotalCodewordsCount: getTotalCodewordsCount\n};\nvar EXP_TABLE = typedarrayBuffer.alloc(512);\nvar LOG_TABLE = typedarrayBuffer.alloc(256);\n(function initTables() {\n    var x = 1;\n    for (var i = 0; i < 255; i++) {\n        EXP_TABLE[i] = x;\n        LOG_TABLE[x] = i;\n        x <<= 1; // multiply by 2\n        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n        // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n        if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n            x ^= 0x11D;\n        }\n    }\n    // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n    // stay inside the bounds (because we will mainly use this table for the multiplication of\n    // two GF numbers, no more).\n    // @see {@link mul}\n    for (i = 255; i < 512; i++) {\n        EXP_TABLE[i] = EXP_TABLE[i - 255];\n    }\n}());\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar log = function log(n) {\n    if (n < 1)\n        throw new Error('log(' + n + ')');\n    return LOG_TABLE[n];\n};\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nvar exp = function exp(n) {\n    return EXP_TABLE[n];\n};\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nvar mul = function mul(x, y) {\n    if (x === 0 || y === 0)\n        return 0;\n    // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n    // @see {@link initTables}\n    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n};\nvar galoisField = {\n    log: log,\n    exp: exp,\n    mul: mul\n};\nvar polynomial = createCommonjsModule(function (module, exports) {\n    /**\n     * Multiplies two polynomials inside Galois Field\n     *\n     * @param  {Buffer} p1 Polynomial\n     * @param  {Buffer} p2 Polynomial\n     * @return {Buffer}    Product of p1 and p2\n     */\n    exports.mul = function mul(p1, p2) {\n        var coeff = typedarrayBuffer.alloc(p1.length + p2.length - 1);\n        for (var i = 0; i < p1.length; i++) {\n            for (var j = 0; j < p2.length; j++) {\n                coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);\n            }\n        }\n        return coeff;\n    };\n    /**\n     * Calculate the remainder of polynomials division\n     *\n     * @param  {Buffer} divident Polynomial\n     * @param  {Buffer} divisor  Polynomial\n     * @return {Buffer}          Remainder\n     */\n    exports.mod = function mod(divident, divisor) {\n        var result = typedarrayBuffer.from(divident);\n        while ((result.length - divisor.length) >= 0) {\n            var coeff = result[0];\n            for (var i = 0; i < divisor.length; i++) {\n                result[i] ^= galoisField.mul(divisor[i], coeff);\n            }\n            // remove all zeros from buffer head\n            var offset = 0;\n            while (offset < result.length && result[offset] === 0)\n                offset++;\n            result = result.slice(offset);\n        }\n        return result;\n    };\n    /**\n     * Generate an irreducible generator polynomial of specified degree\n     * (used by Reed-Solomon encoder)\n     *\n     * @param  {Number} degree Degree of the generator polynomial\n     * @return {Buffer}        Buffer containing polynomial coefficients\n     */\n    exports.generateECPolynomial = function generateECPolynomial(degree) {\n        var poly = typedarrayBuffer.from([1]);\n        for (var i = 0; i < degree; i++) {\n            poly = exports.mul(poly, [1, galoisField.exp(i)]);\n        }\n        return poly;\n    };\n});\nvar Buffer$1 = buffer__WEBPACK_IMPORTED_MODULE_8___default.a.Buffer;\nfunction ReedSolomonEncoder(degree) {\n    this.genPoly = undefined;\n    this.degree = degree;\n    if (this.degree)\n        this.initialize(this.degree);\n}\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n    // create an irreducible generator polynomial\n    this.degree = degree;\n    this.genPoly = polynomial.generateECPolynomial(this.degree);\n};\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode(data) {\n    if (!this.genPoly) {\n        throw new Error('Encoder not initialized');\n    }\n    // Calculate EC for this data block\n    // extends data size to data+genPoly size\n    var pad = typedarrayBuffer.alloc(this.degree);\n    var paddedData = Buffer$1.concat([data, pad], data.length + this.degree);\n    // The error correction codewords are the remainder after dividing the data codewords\n    // by a generator polynomial\n    var remainder = polynomial.mod(paddedData, this.genPoly);\n    // return EC data blocks (last n byte, where n is the degree of genPoly)\n    // If coefficients number in remainder are less than genPoly degree,\n    // pad with 0s to the left to reach the needed number of coefficients\n    var start = this.degree - remainder.length;\n    if (start > 0) {\n        var buff = typedarrayBuffer.alloc(this.degree);\n        remainder.copy(buff, start);\n        return buff;\n    }\n    return remainder;\n};\nvar reedSolomonEncoder = ReedSolomonEncoder;\n/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nvar isValid = function isValid(version) {\n    return !isNaN(version) && version >= 1 && version <= 40;\n};\nvar versionCheck = {\n    isValid: isValid\n};\nvar numeric = '[0-9]+';\nvar alphanumeric = '[A-Z $%*+\\\\-./:]+';\nvar kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n    '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n    '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n    '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';\nkanji = kanji.replace(/u/g, '\\\\u');\nvar byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+';\nvar KANJI = new RegExp(kanji, 'g');\nvar BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g');\nvar BYTE = new RegExp(byte, 'g');\nvar NUMERIC = new RegExp(numeric, 'g');\nvar ALPHANUMERIC = new RegExp(alphanumeric, 'g');\nvar TEST_KANJI = new RegExp('^' + kanji + '$');\nvar TEST_NUMERIC = new RegExp('^' + numeric + '$');\nvar TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$');\nvar testKanji = function testKanji(str) {\n    return TEST_KANJI.test(str);\n};\nvar testNumeric = function testNumeric(str) {\n    return TEST_NUMERIC.test(str);\n};\nvar testAlphanumeric = function testAlphanumeric(str) {\n    return TEST_ALPHANUMERIC.test(str);\n};\nvar regex = {\n    KANJI: KANJI,\n    BYTE_KANJI: BYTE_KANJI,\n    BYTE: BYTE,\n    NUMERIC: NUMERIC,\n    ALPHANUMERIC: ALPHANUMERIC,\n    testKanji: testKanji,\n    testNumeric: testNumeric,\n    testAlphanumeric: testAlphanumeric\n};\nvar mode = createCommonjsModule(function (module, exports) {\n    /**\n     * Numeric mode encodes data from the decimal digit set (0 - 9)\n     * (byte values 30HEX to 39HEX).\n     * Normally, 3 data characters are represented by 10 bits.\n     *\n     * @type {Object}\n     */\n    exports.NUMERIC = {\n        id: 'Numeric',\n        bit: 1 << 0,\n        ccBits: [10, 12, 14]\n    };\n    /**\n     * Alphanumeric mode encodes data from a set of 45 characters,\n     * i.e. 10 numeric digits (0 - 9),\n     *      26 alphabetic characters (A - Z),\n     *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n     * Normally, two input characters are represented by 11 bits.\n     *\n     * @type {Object}\n     */\n    exports.ALPHANUMERIC = {\n        id: 'Alphanumeric',\n        bit: 1 << 1,\n        ccBits: [9, 11, 13]\n    };\n    /**\n     * In byte mode, data is encoded at 8 bits per character.\n     *\n     * @type {Object}\n     */\n    exports.BYTE = {\n        id: 'Byte',\n        bit: 1 << 2,\n        ccBits: [8, 16, 16]\n    };\n    /**\n     * The Kanji mode efficiently encodes Kanji characters in accordance with\n     * the Shift JIS system based on JIS X 0208.\n     * The Shift JIS values are shifted from the JIS X 0208 values.\n     * JIS X 0208 gives details of the shift coded representation.\n     * Each two-byte character value is compacted to a 13-bit binary codeword.\n     *\n     * @type {Object}\n     */\n    exports.KANJI = {\n        id: 'Kanji',\n        bit: 1 << 3,\n        ccBits: [8, 10, 12]\n    };\n    /**\n     * Mixed mode will contain a sequences of data in a combination of any of\n     * the modes described above\n     *\n     * @type {Object}\n     */\n    exports.MIXED = {\n        bit: -1\n    };\n    /**\n     * Returns the number of bits needed to store the data length\n     * according to QR Code specifications.\n     *\n     * @param  {Mode}   mode    Data mode\n     * @param  {Number} version QR Code version\n     * @return {Number}         Number of bits\n     */\n    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n        if (!mode.ccBits)\n            throw new Error('Invalid mode: ' + mode);\n        if (!versionCheck.isValid(version)) {\n            throw new Error('Invalid version: ' + version);\n        }\n        if (version >= 1 && version < 10)\n            return mode.ccBits[0];\n        else if (version < 27)\n            return mode.ccBits[1];\n        return mode.ccBits[2];\n    };\n    /**\n     * Returns the most efficient mode to store the specified data\n     *\n     * @param  {String} dataStr Input data string\n     * @return {Mode}           Best mode\n     */\n    exports.getBestModeForData = function getBestModeForData(dataStr) {\n        if (regex.testNumeric(dataStr))\n            return exports.NUMERIC;\n        else if (regex.testAlphanumeric(dataStr))\n            return exports.ALPHANUMERIC;\n        else if (regex.testKanji(dataStr))\n            return exports.KANJI;\n        else\n            return exports.BYTE;\n    };\n    /**\n     * Return mode name as string\n     *\n     * @param {Mode} mode Mode object\n     * @returns {String}  Mode name\n     */\n    exports.toString = function toString(mode) {\n        if (mode && mode.id)\n            return mode.id;\n        throw new Error('Invalid mode');\n    };\n    /**\n     * Check if input param is a valid mode object\n     *\n     * @param   {Mode}    mode Mode object\n     * @returns {Boolean} True if valid mode, false otherwise\n     */\n    exports.isValid = function isValid(mode) {\n        return mode && mode.bit && mode.ccBits;\n    };\n    /**\n     * Get mode object from its name\n     *\n     * @param   {String} string Mode name\n     * @returns {Mode}          Mode object\n     */\n    function fromString(string) {\n        if (typeof string !== 'string') {\n            throw new Error('Param is not a string');\n        }\n        var lcStr = string.toLowerCase();\n        switch (lcStr) {\n            case 'numeric':\n                return exports.NUMERIC;\n            case 'alphanumeric':\n                return exports.ALPHANUMERIC;\n            case 'kanji':\n                return exports.KANJI;\n            case 'byte':\n                return exports.BYTE;\n            default:\n                throw new Error('Unknown mode: ' + string);\n        }\n    }\n    /**\n     * Returns mode from a value.\n     * If value is not a valid mode, returns defaultValue\n     *\n     * @param  {Mode|String} value        Encoding mode\n     * @param  {Mode}        defaultValue Fallback value\n     * @return {Mode}                     Encoding mode\n     */\n    exports.from = function from(value, defaultValue) {\n        if (exports.isValid(value)) {\n            return value;\n        }\n        try {\n            return fromString(value);\n        }\n        catch (e) {\n            return defaultValue;\n        }\n    };\n});\nvar version = createCommonjsModule(function (module, exports) {\n    // Generator polynomial used to encode version information\n    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);\n    var G18_BCH = utils.getBCHDigit(G18);\n    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n                return currentVersion;\n            }\n        }\n        return undefined;\n    }\n    function getReservedBitsCount(mode$1, version) {\n        // Character count indicator + mode indicator bits\n        return mode.getCharCountIndicator(mode$1, version) + 4;\n    }\n    function getTotalBitsFromDataArray(segments, version) {\n        var totalBits = 0;\n        segments.forEach(function (data) {\n            var reservedBits = getReservedBitsCount(data.mode, version);\n            totalBits += reservedBits + data.getBitsLength();\n        });\n        return totalBits;\n    }\n    function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n        for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n            var length = getTotalBitsFromDataArray(segments, currentVersion);\n            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode.MIXED)) {\n                return currentVersion;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Returns version number from a value.\n     * If value is not a valid version, returns defaultValue\n     *\n     * @param  {Number|String} value        QR Code version\n     * @param  {Number}        defaultValue Fallback value\n     * @return {Number}                     QR Code version number\n     */\n    exports.from = function from(value, defaultValue) {\n        if (versionCheck.isValid(value)) {\n            return parseInt(value, 10);\n        }\n        return defaultValue;\n    };\n    /**\n     * Returns how much data can be stored with the specified QR code version\n     * and error correction level\n     *\n     * @param  {Number} version              QR Code version (1-40)\n     * @param  {Number} errorCorrectionLevel Error correction level\n     * @param  {Mode}   mode                 Data mode\n     * @return {Number}                      Quantity of storable data\n     */\n    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode$1) {\n        if (!versionCheck.isValid(version)) {\n            throw new Error('Invalid QR Code version');\n        }\n        // Use Byte mode as default\n        if (typeof mode$1 === 'undefined')\n            mode$1 = mode.BYTE;\n        // Total codewords for this QR code version (Data + Error correction)\n        var totalCodewords = utils.getSymbolTotalCodewords(version);\n        // Total number of error correction codewords\n        var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n        // Total number of data codewords\n        var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n        if (mode$1 === mode.MIXED)\n            return dataTotalCodewordsBits;\n        var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode$1, version);\n        // Return max number of storable codewords\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return Math.floor((usableBits / 10) * 3);\n            case mode.ALPHANUMERIC:\n                return Math.floor((usableBits / 11) * 2);\n            case mode.KANJI:\n                return Math.floor(usableBits / 13);\n            case mode.BYTE:\n            default:\n                return Math.floor(usableBits / 8);\n        }\n    };\n    /**\n     * Returns the minimum version needed to contain the amount of data\n     *\n     * @param  {Segment} data                    Segment of data\n     * @param  {Number} [errorCorrectionLevel=H] Error correction level\n     * @param  {Mode} mode                       Data mode\n     * @return {Number}                          QR Code version\n     */\n    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel$1) {\n        var seg;\n        var ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);\n        if (isarray(data)) {\n            if (data.length > 1) {\n                return getBestVersionForMixedData(data, ecl);\n            }\n            if (data.length === 0) {\n                return 1;\n            }\n            seg = data[0];\n        }\n        else {\n            seg = data;\n        }\n        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n    };\n    /**\n     * Returns version information with relative error correction bits\n     *\n     * The version information is included in QR Code symbols of version 7 or larger.\n     * It consists of an 18-bit sequence containing 6 data bits,\n     * with 12 error correction bits calculated using the (18, 6) Golay code.\n     *\n     * @param  {Number} version QR Code version\n     * @return {Number}         Encoded version info bits\n     */\n    exports.getEncodedBits = function getEncodedBits(version) {\n        if (!versionCheck.isValid(version) || version < 7) {\n            throw new Error('Invalid QR Code version');\n        }\n        var d = version << 12;\n        while (utils.getBCHDigit(d) - G18_BCH >= 0) {\n            d ^= (G18 << (utils.getBCHDigit(d) - G18_BCH));\n        }\n        return (version << 12) | d;\n    };\n});\nvar G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);\nvar G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);\nvar G15_BCH = utils.getBCHDigit(G15);\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nvar getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n    var data = ((errorCorrectionLevel.bit << 3) | mask);\n    var d = data << 10;\n    while (utils.getBCHDigit(d) - G15_BCH >= 0) {\n        d ^= (G15 << (utils.getBCHDigit(d) - G15_BCH));\n    }\n    // xor final data with mask pattern in order to ensure that\n    // no combination of Error Correction Level and data mask pattern\n    // will result in an all-zero data string\n    return ((data << 10) | d) ^ G15_MASK;\n};\nvar formatInfo = {\n    getEncodedBits: getEncodedBits\n};\nfunction NumericData(data) {\n    this.mode = mode.NUMERIC;\n    this.data = data.toString();\n}\nNumericData.getBitsLength = function getBitsLength(length) {\n    return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0);\n};\nNumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nNumericData.prototype.getBitsLength = function getBitsLength() {\n    return NumericData.getBitsLength(this.data.length);\n};\nNumericData.prototype.write = function write(bitBuffer) {\n    var i, group, value;\n    // The input data string is divided into groups of three digits,\n    // and each group is converted to its 10-bit binary equivalent.\n    for (i = 0; i + 3 <= this.data.length; i += 3) {\n        group = this.data.substr(i, 3);\n        value = parseInt(group, 10);\n        bitBuffer.put(value, 10);\n    }\n    // If the number of input digits is not an exact multiple of three,\n    // the final one or two digits are converted to 4 or 7 bits respectively.\n    var remainingNum = this.data.length - i;\n    if (remainingNum > 0) {\n        group = this.data.substr(i);\n        value = parseInt(group, 10);\n        bitBuffer.put(value, remainingNum * 3 + 1);\n    }\n};\nvar numericData = NumericData;\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nvar ALPHA_NUM_CHARS = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n];\nfunction AlphanumericData(data) {\n    this.mode = mode.ALPHANUMERIC;\n    this.data = data;\n}\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n    return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\nAlphanumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n    return AlphanumericData.getBitsLength(this.data.length);\n};\nAlphanumericData.prototype.write = function write(bitBuffer) {\n    var i;\n    // Input data characters are divided into groups of two characters\n    // and encoded as 11-bit binary codes.\n    for (i = 0; i + 2 <= this.data.length; i += 2) {\n        // The character value of the first character is multiplied by 45\n        var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n        // The character value of the second digit is added to the product\n        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n        // The sum is then stored as 11-bit binary number\n        bitBuffer.put(value, 11);\n    }\n    // If the number of input data characters is not a multiple of two,\n    // the character value of the final character is encoded as a 6-bit binary number.\n    if (this.data.length % 2) {\n        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n    }\n};\nvar alphanumericData = AlphanumericData;\nfunction ByteData(data) {\n    this.mode = mode.BYTE;\n    this.data = typedarrayBuffer.from(data);\n}\nByteData.getBitsLength = function getBitsLength(length) {\n    return length * 8;\n};\nByteData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nByteData.prototype.getBitsLength = function getBitsLength() {\n    return ByteData.getBitsLength(this.data.length);\n};\nByteData.prototype.write = function (bitBuffer) {\n    for (var i = 0, l = this.data.length; i < l; i++) {\n        bitBuffer.put(this.data[i], 8);\n    }\n};\nvar byteData = ByteData;\nfunction KanjiData(data) {\n    this.mode = mode.KANJI;\n    this.data = data;\n}\nKanjiData.getBitsLength = function getBitsLength(length) {\n    return length * 13;\n};\nKanjiData.prototype.getLength = function getLength() {\n    return this.data.length;\n};\nKanjiData.prototype.getBitsLength = function getBitsLength() {\n    return KanjiData.getBitsLength(this.data.length);\n};\nKanjiData.prototype.write = function (bitBuffer) {\n    var i;\n    // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n    // These byte values are shifted from the JIS X 0208 values.\n    // JIS X 0208 gives details of the shift coded representation.\n    for (i = 0; i < this.data.length; i++) {\n        var value = utils.toSJIS(this.data[i]);\n        // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n        if (value >= 0x8140 && value <= 0x9FFC) {\n            // Subtract 0x8140 from Shift JIS value\n            value -= 0x8140;\n            // For characters with Shift JIS values from 0xE040 to 0xEBBF\n        }\n        else if (value >= 0xE040 && value <= 0xEBBF) {\n            // Subtract 0xC140 from Shift JIS value\n            value -= 0xC140;\n        }\n        else {\n            throw new Error('Invalid SJIS character: ' + this.data[i] + '\\n' +\n                'Make sure your charset is UTF-8');\n        }\n        // Multiply most significant byte of result by 0xC0\n        // and add least significant byte to product\n        value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);\n        // Convert result to a 13-bit binary string\n        bitBuffer.put(value, 13);\n    }\n};\nvar kanjiData = KanjiData;\nvar dijkstra_1 = createCommonjsModule(function (module) {\n    /******************************************************************************\n     * Created 2008-08-19.\n     *\n     * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n     *\n     * Copyright (C) 2008\n     *   Wyatt Baldwin <self@wyattbaldwin.com>\n     *   All rights reserved\n     *\n     * Licensed under the MIT license.\n     *\n     *   http://www.opensource.org/licenses/mit-license.php\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     *****************************************************************************/\n    var dijkstra = {\n        single_source_shortest_paths: function (graph, s, d) {\n            // Predecessor map for each node that has been encountered.\n            // node ID => predecessor node ID\n            var predecessors = {};\n            // Costs of shortest paths from s to all nodes encountered.\n            // node ID => cost\n            var costs = {};\n            costs[s] = 0;\n            // Costs of shortest paths from s to all nodes encountered; differs from\n            // `costs` in that it provides easy access to the node that currently has\n            // the known shortest path from s.\n            // XXX: Do we actually need both `costs` and `open`?\n            var open = dijkstra.PriorityQueue.make();\n            open.push(s, 0);\n            var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n            while (!open.empty()) {\n                // In the nodes remaining in graph that have a known cost from s,\n                // find the node, u, that currently has the shortest path from s.\n                closest = open.pop();\n                u = closest.value;\n                cost_of_s_to_u = closest.cost;\n                // Get nodes adjacent to u...\n                adjacent_nodes = graph[u] || {};\n                // ...and explore the edges that connect u to those nodes, updating\n                // the cost of the shortest paths to any or all of those nodes as\n                // necessary. v is the node across the current edge from u.\n                for (v in adjacent_nodes) {\n                    if (adjacent_nodes.hasOwnProperty(v)) {\n                        // Get the cost of the edge running from u to v.\n                        cost_of_e = adjacent_nodes[v];\n                        // Cost of s to u plus the cost of u to v across e--this is *a*\n                        // cost from s to v that may or may not be less than the current\n                        // known cost to v.\n                        cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n                        // If we haven't visited v yet OR if the current known cost from s to\n                        // v is greater than the new cost we just found (cost of s to u plus\n                        // cost of u to v across e), update v's cost in the cost list and\n                        // update v's predecessor in the predecessor list (it's now u).\n                        cost_of_s_to_v = costs[v];\n                        first_visit = (typeof costs[v] === 'undefined');\n                        if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n                            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n                            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n                            predecessors[v] = u;\n                        }\n                    }\n                }\n            }\n            if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n                var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n                throw new Error(msg);\n            }\n            return predecessors;\n        },\n        extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n            var nodes = [];\n            var u = d;\n            while (u) {\n                nodes.push(u);\n                u = predecessors[u];\n            }\n            nodes.reverse();\n            return nodes;\n        },\n        find_path: function (graph, s, d) {\n            var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n            return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n        },\n        /**\n         * A very naive priority queue implementation.\n         */\n        PriorityQueue: {\n            make: function (opts) {\n                var T = dijkstra.PriorityQueue, t = {}, key;\n                opts = opts || {};\n                for (key in T) {\n                    if (T.hasOwnProperty(key)) {\n                        t[key] = T[key];\n                    }\n                }\n                t.queue = [];\n                t.sorter = opts.sorter || T.default_sorter;\n                return t;\n            },\n            default_sorter: function (a, b) {\n                return a.cost - b.cost;\n            },\n            /**\n             * Add a new item to the queue and ensure the highest priority element\n             * is at the front of the queue.\n             */\n            push: function (value, cost) {\n                var item = { value: value, cost: cost };\n                this.queue.push(item);\n                this.queue.sort(this.sorter);\n            },\n            /**\n             * Return the highest priority element in the queue.\n             */\n            pop: function () {\n                return this.queue.shift();\n            },\n            empty: function () {\n                return this.queue.length === 0;\n            }\n        }\n    };\n    // node.js module exports\n    {\n        module.exports = dijkstra;\n    }\n});\nvar segments = createCommonjsModule(function (module, exports) {\n    /**\n     * Returns UTF8 byte length\n     *\n     * @param  {String} str Input string\n     * @return {Number}     Number of byte\n     */\n    function getStringByteLength(str) {\n        return unescape(encodeURIComponent(str)).length;\n    }\n    /**\n     * Get a list of segments of the specified mode\n     * from a string\n     *\n     * @param  {Mode}   mode Segment mode\n     * @param  {String} str  String to process\n     * @return {Array}       Array of object with segments data\n     */\n    function getSegments(regex, mode, str) {\n        var segments = [];\n        var result;\n        while ((result = regex.exec(str)) !== null) {\n            segments.push({\n                data: result[0],\n                index: result.index,\n                mode: mode,\n                length: result[0].length\n            });\n        }\n        return segments;\n    }\n    /**\n     * Extracts a series of segments with the appropriate\n     * modes from a string\n     *\n     * @param  {String} dataStr Input string\n     * @return {Array}          Array of object with segments data\n     */\n    function getSegmentsFromString(dataStr) {\n        var numSegs = getSegments(regex.NUMERIC, mode.NUMERIC, dataStr);\n        var alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode.ALPHANUMERIC, dataStr);\n        var byteSegs;\n        var kanjiSegs;\n        if (utils.isKanjiModeEnabled()) {\n            byteSegs = getSegments(regex.BYTE, mode.BYTE, dataStr);\n            kanjiSegs = getSegments(regex.KANJI, mode.KANJI, dataStr);\n        }\n        else {\n            byteSegs = getSegments(regex.BYTE_KANJI, mode.BYTE, dataStr);\n            kanjiSegs = [];\n        }\n        var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n        return segs\n            .sort(function (s1, s2) {\n            return s1.index - s2.index;\n        })\n            .map(function (obj) {\n            return {\n                data: obj.data,\n                mode: obj.mode,\n                length: obj.length\n            };\n        });\n    }\n    /**\n     * Returns how many bits are needed to encode a string of\n     * specified length with the specified mode\n     *\n     * @param  {Number} length String length\n     * @param  {Mode} mode     Segment mode\n     * @return {Number}        Bit length\n     */\n    function getSegmentBitsLength(length, mode$1) {\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return numericData.getBitsLength(length);\n            case mode.ALPHANUMERIC:\n                return alphanumericData.getBitsLength(length);\n            case mode.KANJI:\n                return kanjiData.getBitsLength(length);\n            case mode.BYTE:\n                return byteData.getBitsLength(length);\n        }\n    }\n    /**\n     * Merges adjacent segments which have the same mode\n     *\n     * @param  {Array} segs Array of object with segments data\n     * @return {Array}      Array of object with segments data\n     */\n    function mergeSegments(segs) {\n        return segs.reduce(function (acc, curr) {\n            var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n            if (prevSeg && prevSeg.mode === curr.mode) {\n                acc[acc.length - 1].data += curr.data;\n                return acc;\n            }\n            acc.push(curr);\n            return acc;\n        }, []);\n    }\n    /**\n     * Generates a list of all possible nodes combination which\n     * will be used to build a segments graph.\n     *\n     * Nodes are divided by groups. Each group will contain a list of all the modes\n     * in which is possible to encode the given text.\n     *\n     * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n     * The group for '12345' will contain then 3 objects, one for each\n     * possible encoding mode.\n     *\n     * Each node represents a possible segment.\n     *\n     * @param  {Array} segs Array of object with segments data\n     * @return {Array}      Array of object with segments data\n     */\n    function buildNodes(segs) {\n        var nodes = [];\n        for (var i = 0; i < segs.length; i++) {\n            var seg = segs[i];\n            switch (seg.mode) {\n                case mode.NUMERIC:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.ALPHANUMERIC, length: seg.length },\n                        { data: seg.data, mode: mode.BYTE, length: seg.length }\n                    ]);\n                    break;\n                case mode.ALPHANUMERIC:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.BYTE, length: seg.length }\n                    ]);\n                    break;\n                case mode.KANJI:\n                    nodes.push([seg,\n                        { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }\n                    ]);\n                    break;\n                case mode.BYTE:\n                    nodes.push([\n                        { data: seg.data, mode: mode.BYTE, length: getStringByteLength(seg.data) }\n                    ]);\n            }\n        }\n        return nodes;\n    }\n    /**\n     * Builds a graph from a list of nodes.\n     * All segments in each node group will be connected with all the segments of\n     * the next group and so on.\n     *\n     * At each connection will be assigned a weight depending on the\n     * segment's byte length.\n     *\n     * @param  {Array} nodes    Array of object with segments data\n     * @param  {Number} version QR Code version\n     * @return {Object}         Graph of all possible segments\n     */\n    function buildGraph(nodes, version) {\n        var table = {};\n        var graph = { 'start': {} };\n        var prevNodeIds = ['start'];\n        for (var i = 0; i < nodes.length; i++) {\n            var nodeGroup = nodes[i];\n            var currentNodeIds = [];\n            for (var j = 0; j < nodeGroup.length; j++) {\n                var node = nodeGroup[j];\n                var key = '' + i + j;\n                currentNodeIds.push(key);\n                table[key] = { node: node, lastCount: 0 };\n                graph[key] = {};\n                for (var n = 0; n < prevNodeIds.length; n++) {\n                    var prevNodeId = prevNodeIds[n];\n                    if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n                        graph[prevNodeId][key] =\n                            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n                                getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n                        table[prevNodeId].lastCount += node.length;\n                    }\n                    else {\n                        if (table[prevNodeId])\n                            table[prevNodeId].lastCount = node.length;\n                        graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n                            4 + mode.getCharCountIndicator(node.mode, version); // switch cost\n                    }\n                }\n            }\n            prevNodeIds = currentNodeIds;\n        }\n        for (n = 0; n < prevNodeIds.length; n++) {\n            graph[prevNodeIds[n]]['end'] = 0;\n        }\n        return { map: graph, table: table };\n    }\n    /**\n     * Builds a segment from a specified data and mode.\n     * If a mode is not specified, the more suitable will be used.\n     *\n     * @param  {String} data             Input data\n     * @param  {Mode | String} modesHint Data mode\n     * @return {Segment}                 Segment\n     */\n    function buildSingleSegment(data, modesHint) {\n        var mode$1;\n        var bestMode = mode.getBestModeForData(data);\n        mode$1 = mode.from(modesHint, bestMode);\n        // Make sure data can be encoded\n        if (mode$1 !== mode.BYTE && mode$1.bit < bestMode.bit) {\n            throw new Error('\"' + data + '\"' +\n                ' cannot be encoded with mode ' + mode.toString(mode$1) +\n                '.\\n Suggested mode is: ' + mode.toString(bestMode));\n        }\n        // Use Mode.BYTE if Kanji support is disabled\n        if (mode$1 === mode.KANJI && !utils.isKanjiModeEnabled()) {\n            mode$1 = mode.BYTE;\n        }\n        switch (mode$1) {\n            case mode.NUMERIC:\n                return new numericData(data);\n            case mode.ALPHANUMERIC:\n                return new alphanumericData(data);\n            case mode.KANJI:\n                return new kanjiData(data);\n            case mode.BYTE:\n                return new byteData(data);\n        }\n    }\n    /**\n     * Builds a list of segments from an array.\n     * Array can contain Strings or Objects with segment's info.\n     *\n     * For each item which is a string, will be generated a segment with the given\n     * string and the more appropriate encoding mode.\n     *\n     * For each item which is an object, will be generated a segment with the given\n     * data and mode.\n     * Objects must contain at least the property \"data\".\n     * If property \"mode\" is not present, the more suitable mode will be used.\n     *\n     * @param  {Array} array Array of objects with segments data\n     * @return {Array}       Array of Segments\n     */\n    exports.fromArray = function fromArray(array) {\n        return array.reduce(function (acc, seg) {\n            if (typeof seg === 'string') {\n                acc.push(buildSingleSegment(seg, null));\n            }\n            else if (seg.data) {\n                acc.push(buildSingleSegment(seg.data, seg.mode));\n            }\n            return acc;\n        }, []);\n    };\n    /**\n     * Builds an optimized sequence of segments from a string,\n     * which will produce the shortest possible bitstream.\n     *\n     * @param  {String} data    Input string\n     * @param  {Number} version QR Code version\n     * @return {Array}          Array of segments\n     */\n    exports.fromString = function fromString(data, version) {\n        var segs = getSegmentsFromString(data, utils.isKanjiModeEnabled());\n        var nodes = buildNodes(segs);\n        var graph = buildGraph(nodes, version);\n        var path = dijkstra_1.find_path(graph.map, 'start', 'end');\n        var optimizedSegs = [];\n        for (var i = 1; i < path.length - 1; i++) {\n            optimizedSegs.push(graph.table[path[i]].node);\n        }\n        return exports.fromArray(mergeSegments(optimizedSegs));\n    };\n    /**\n     * Splits a string in various segments with the modes which\n     * best represent their content.\n     * The produced segments are far from being optimized.\n     * The output of this function is only used to estimate a QR Code version\n     * which may contain the data.\n     *\n     * @param  {string} data Input string\n     * @return {Array}       Array of segments\n     */\n    exports.rawSplit = function rawSplit(data) {\n        return exports.fromArray(getSegmentsFromString(data, utils.isKanjiModeEnabled()));\n    };\n});\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern(matrix, version) {\n    var size = matrix.size;\n    var pos = finderPattern.getPositions(version);\n    for (var i = 0; i < pos.length; i++) {\n        var row = pos[i][0];\n        var col = pos[i][1];\n        for (var r = -1; r <= 7; r++) {\n            if (row + r <= -1 || size <= row + r)\n                continue;\n            for (var c = -1; c <= 7; c++) {\n                if (col + c <= -1 || size <= col + c)\n                    continue;\n                if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n                    (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n                    (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n                    matrix.set(row + r, col + c, true, true);\n                }\n                else {\n                    matrix.set(row + r, col + c, false, true);\n                }\n            }\n        }\n    }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern(matrix) {\n    var size = matrix.size;\n    for (var r = 8; r < size - 8; r++) {\n        var value = r % 2 === 0;\n        matrix.set(r, 6, value, true);\n        matrix.set(6, r, value, true);\n    }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern(matrix, version) {\n    var pos = alignmentPattern.getPositions(version);\n    for (var i = 0; i < pos.length; i++) {\n        var row = pos[i][0];\n        var col = pos[i][1];\n        for (var r = -2; r <= 2; r++) {\n            for (var c = -2; c <= 2; c++) {\n                if (r === -2 || r === 2 || c === -2 || c === 2 ||\n                    (r === 0 && c === 0)) {\n                    matrix.set(row + r, col + c, true, true);\n                }\n                else {\n                    matrix.set(row + r, col + c, false, true);\n                }\n            }\n        }\n    }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo(matrix, version$1) {\n    var size = matrix.size;\n    var bits = version.getEncodedBits(version$1);\n    var row, col, mod;\n    for (var i = 0; i < 18; i++) {\n        row = Math.floor(i / 3);\n        col = i % 3 + size - 8 - 3;\n        mod = ((bits >> i) & 1) === 1;\n        matrix.set(row, col, mod, true);\n        matrix.set(col, row, mod, true);\n    }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n    var size = matrix.size;\n    var bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n    var i, mod;\n    for (i = 0; i < 15; i++) {\n        mod = ((bits >> i) & 1) === 1;\n        // vertical\n        if (i < 6) {\n            matrix.set(i, 8, mod, true);\n        }\n        else if (i < 8) {\n            matrix.set(i + 1, 8, mod, true);\n        }\n        else {\n            matrix.set(size - 15 + i, 8, mod, true);\n        }\n        // horizontal\n        if (i < 8) {\n            matrix.set(8, size - i - 1, mod, true);\n        }\n        else if (i < 9) {\n            matrix.set(8, 15 - i - 1 + 1, mod, true);\n        }\n        else {\n            matrix.set(8, 15 - i - 1, mod, true);\n        }\n    }\n    // fixed module\n    matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\nfunction setupData(matrix, data) {\n    var size = matrix.size;\n    var inc = -1;\n    var row = size - 1;\n    var bitIndex = 7;\n    var byteIndex = 0;\n    for (var col = size - 1; col > 0; col -= 2) {\n        if (col === 6)\n            col--;\n        while (true) {\n            for (var c = 0; c < 2; c++) {\n                if (!matrix.isReserved(row, col - c)) {\n                    var dark = false;\n                    if (byteIndex < data.length) {\n                        dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);\n                    }\n                    matrix.set(row, col - c, dark);\n                    bitIndex--;\n                    if (bitIndex === -1) {\n                        byteIndex++;\n                        bitIndex = 7;\n                    }\n                }\n            }\n            row += inc;\n            if (row < 0 || size <= row) {\n                row -= inc;\n                inc = -inc;\n                break;\n            }\n        }\n    }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\nfunction createData(version, errorCorrectionLevel, segments) {\n    // Prepare data buffer\n    var buffer = new bitBuffer();\n    segments.forEach(function (data) {\n        // prefix data with mode indicator (4 bits)\n        buffer.put(data.mode.bit, 4);\n        // Prefix data with character count indicator.\n        // The character count indicator is a string of bits that represents the\n        // number of characters that are being encoded.\n        // The character count indicator must be placed after the mode indicator\n        // and must be a certain number of bits long, depending on the QR version\n        // and data mode\n        // @see {@link Mode.getCharCountIndicator}.\n        buffer.put(data.getLength(), mode.getCharCountIndicator(data.mode, version));\n        // add binary data sequence to buffer\n        data.write(buffer);\n    });\n    // Calculate required number of bits\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    // Add a terminator.\n    // If the bit string is shorter than the total number of required bits,\n    // a terminator of up to four 0s must be added to the right side of the string.\n    // If the bit string is more than four bits shorter than the required number of bits,\n    // add four 0s to the end.\n    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n        buffer.put(0, 4);\n    }\n    // If the bit string is fewer than four bits shorter, add only the number of 0s that\n    // are needed to reach the required number of bits.\n    // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n    // pad the string on the right with 0s to make the string's length a multiple of 8.\n    while (buffer.getLengthInBits() % 8 !== 0) {\n        buffer.putBit(0);\n    }\n    // Add pad bytes if the string is still shorter than the total number of required bits.\n    // Extend the buffer to fill the data capacity of the symbol corresponding to\n    // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n    // and 00010001 (0x11) alternately.\n    var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n    for (var i = 0; i < remainingByte; i++) {\n        buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n    }\n    return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n    // Total codewords for this QR code version (Data + Error correction)\n    var totalCodewords = utils.getSymbolTotalCodewords(version);\n    // Total number of error correction codewords\n    var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    // Total number of data codewords\n    var dataTotalCodewords = totalCodewords - ecTotalCodewords;\n    // Total number of blocks\n    var ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel);\n    // Calculate how many blocks each group should contain\n    var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n    var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n    var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n    var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n    var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n    // Number of EC codewords is the same for both groups\n    var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n    // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n    var rs = new reedSolomonEncoder(ecCount);\n    var offset = 0;\n    var dcData = new Array(ecTotalBlocks);\n    var ecData = new Array(ecTotalBlocks);\n    var maxDataSize = 0;\n    var buffer = typedarrayBuffer.from(bitBuffer.buffer);\n    // Divide the buffer into the required number of blocks\n    for (var b = 0; b < ecTotalBlocks; b++) {\n        var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n        // extract a block of data from buffer\n        dcData[b] = buffer.slice(offset, offset + dataSize);\n        // Calculate EC codewords for this data block\n        ecData[b] = rs.encode(dcData[b]);\n        offset += dataSize;\n        maxDataSize = Math.max(maxDataSize, dataSize);\n    }\n    // Create final data\n    // Interleave the data and error correction codewords from each block\n    var data = typedarrayBuffer.alloc(totalCodewords);\n    var index = 0;\n    var i, r;\n    // Add data codewords\n    for (i = 0; i < maxDataSize; i++) {\n        for (r = 0; r < ecTotalBlocks; r++) {\n            if (i < dcData[r].length) {\n                data[index++] = dcData[r][i];\n            }\n        }\n    }\n    // Apped EC codewords\n    for (i = 0; i < ecCount; i++) {\n        for (r = 0; r < ecTotalBlocks; r++) {\n            data[index++] = ecData[r][i];\n        }\n    }\n    return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol(data, version$1, errorCorrectionLevel, maskPattern$1) {\n    var segments$1;\n    if (isarray(data)) {\n        segments$1 = segments.fromArray(data);\n    }\n    else if (typeof data === 'string') {\n        var estimatedVersion = version$1;\n        if (!estimatedVersion) {\n            var rawSegments = segments.rawSplit(data);\n            // Estimate best version that can contain raw splitted segments\n            estimatedVersion = version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n        }\n        // Build optimized segments\n        // If estimated version is undefined, try with the highest version\n        segments$1 = segments.fromString(data, estimatedVersion || 40);\n    }\n    else {\n        throw new Error('Invalid data');\n    }\n    // Get the min version that can contain data\n    var bestVersion = version.getBestVersionForData(segments$1, errorCorrectionLevel);\n    // If no version is found, data cannot be stored\n    if (!bestVersion) {\n        throw new Error('The amount of data is too big to be stored in a QR Code');\n    }\n    // If not specified, use min version as default\n    if (!version$1) {\n        version$1 = bestVersion;\n        // Check if the specified version can contain the data\n    }\n    else if (version$1 < bestVersion) {\n        throw new Error('\\n' +\n            'The chosen QR Code version cannot contain this amount of data.\\n' +\n            'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n    }\n    var dataBits = createData(version$1, errorCorrectionLevel, segments$1);\n    // Allocate matrix buffer\n    var moduleCount = utils.getSymbolSize(version$1);\n    var modules = new bitMatrix(moduleCount);\n    // Add function modules\n    setupFinderPattern(modules, version$1);\n    setupTimingPattern(modules);\n    setupAlignmentPattern(modules, version$1);\n    // Add temporary dummy bits for format info just to set them as reserved.\n    // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n    // since the masking operation must be performed only on the encoding region.\n    // These blocks will be replaced with correct values later in code.\n    setupFormatInfo(modules, errorCorrectionLevel, 0);\n    if (version$1 >= 7) {\n        setupVersionInfo(modules, version$1);\n    }\n    // Add data codewords\n    setupData(modules, dataBits);\n    if (isNaN(maskPattern$1)) {\n        // Find best mask pattern\n        maskPattern$1 = maskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n    }\n    // Apply mask pattern\n    maskPattern.applyMask(maskPattern$1, modules);\n    // Replace format info bits with correct values\n    setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);\n    return {\n        modules: modules,\n        version: version$1,\n        errorCorrectionLevel: errorCorrectionLevel,\n        maskPattern: maskPattern$1,\n        segments: segments$1\n    };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nvar create = function create(data, options) {\n    if (typeof data === 'undefined' || data === '') {\n        throw new Error('No input text');\n    }\n    var errorCorrectionLevel$1 = errorCorrectionLevel.M;\n    var version$1;\n    var mask;\n    if (typeof options !== 'undefined') {\n        // Use higher error correction level as default\n        errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);\n        version$1 = version.from(options.version);\n        mask = maskPattern.from(options.maskPattern);\n        if (options.toSJISFunc) {\n            utils.setToSJISFunction(options.toSJISFunc);\n        }\n    }\n    return createSymbol(data, version$1, errorCorrectionLevel$1, mask);\n};\nvar qrcode = {\n    create: create\n};\nvar utils$1 = createCommonjsModule(function (module, exports) {\n    function hex2rgba(hex) {\n        if (typeof hex === 'number') {\n            hex = hex.toString();\n        }\n        if (typeof hex !== 'string') {\n            throw new Error('Color should be defined as hex string');\n        }\n        var hexCode = hex.slice().replace('#', '').split('');\n        if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n            throw new Error('Invalid hex color: ' + hex);\n        }\n        // Convert from short to long form (fff -> ffffff)\n        if (hexCode.length === 3 || hexCode.length === 4) {\n            hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n                return [c, c];\n            }));\n        }\n        // Add default alpha value\n        if (hexCode.length === 6)\n            hexCode.push('F', 'F');\n        var hexValue = parseInt(hexCode.join(''), 16);\n        return {\n            r: (hexValue >> 24) & 255,\n            g: (hexValue >> 16) & 255,\n            b: (hexValue >> 8) & 255,\n            a: hexValue & 255,\n            hex: '#' + hexCode.slice(0, 6).join('')\n        };\n    }\n    exports.getOptions = function getOptions(options) {\n        if (!options)\n            options = {};\n        if (!options.color)\n            options.color = {};\n        var margin = typeof options.margin === 'undefined' ||\n            options.margin === null ||\n            options.margin < 0 ? 4 : options.margin;\n        var width = options.width && options.width >= 21 ? options.width : undefined;\n        var scale = options.scale || 4;\n        return {\n            width: width,\n            scale: width ? 4 : scale,\n            margin: margin,\n            color: {\n                dark: hex2rgba(options.color.dark || '#000000ff'),\n                light: hex2rgba(options.color.light || '#ffffffff')\n            },\n            type: options.type,\n            rendererOpts: options.rendererOpts || {}\n        };\n    };\n    exports.getScale = function getScale(qrSize, opts) {\n        return opts.width && opts.width >= qrSize + opts.margin * 2\n            ? opts.width / (qrSize + opts.margin * 2)\n            : opts.scale;\n    };\n    exports.getImageWidth = function getImageWidth(qrSize, opts) {\n        var scale = exports.getScale(qrSize, opts);\n        return Math.floor((qrSize + opts.margin * 2) * scale);\n    };\n    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n        var size = qr.modules.size;\n        var data = qr.modules.data;\n        var scale = exports.getScale(size, opts);\n        var symbolSize = Math.floor((size + opts.margin * 2) * scale);\n        var scaledMargin = opts.margin * scale;\n        var palette = [opts.color.light, opts.color.dark];\n        for (var i = 0; i < symbolSize; i++) {\n            for (var j = 0; j < symbolSize; j++) {\n                var posDst = (i * symbolSize + j) * 4;\n                var pxColor = opts.color.light;\n                if (i >= scaledMargin && j >= scaledMargin &&\n                    i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n                    var iSrc = Math.floor((i - scaledMargin) / scale);\n                    var jSrc = Math.floor((j - scaledMargin) / scale);\n                    pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n                }\n                imgData[posDst++] = pxColor.r;\n                imgData[posDst++] = pxColor.g;\n                imgData[posDst++] = pxColor.b;\n                imgData[posDst] = pxColor.a;\n            }\n        }\n    };\n});\nvar canvas = createCommonjsModule(function (module, exports) {\n    function clearCanvas(ctx, canvas, size) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        if (!canvas.style)\n            canvas.style = {};\n        canvas.height = size;\n        canvas.width = size;\n        canvas.style.height = size + 'px';\n        canvas.style.width = size + 'px';\n    }\n    function getCanvasElement() {\n        try {\n            return document.createElement('canvas');\n        }\n        catch (e) {\n            throw new Error('You need to specify a canvas element');\n        }\n    }\n    exports.render = function render(qrData, canvas, options) {\n        var opts = options;\n        var canvasEl = canvas;\n        if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n            opts = canvas;\n            canvas = undefined;\n        }\n        if (!canvas) {\n            canvasEl = getCanvasElement();\n        }\n        opts = utils$1.getOptions(opts);\n        var size = utils$1.getImageWidth(qrData.modules.size, opts);\n        var ctx = canvasEl.getContext('2d');\n        var image = ctx.createImageData(size, size);\n        utils$1.qrToImageData(image.data, qrData, opts);\n        clearCanvas(ctx, canvasEl, size);\n        ctx.putImageData(image, 0, 0);\n        return canvasEl;\n    };\n    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n        var opts = options;\n        if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n            opts = canvas;\n            canvas = undefined;\n        }\n        if (!opts)\n            opts = {};\n        var canvasEl = exports.render(qrData, canvas, opts);\n        var type = opts.type || 'image/png';\n        var rendererOpts = opts.rendererOpts || {};\n        return canvasEl.toDataURL(type, rendererOpts.quality);\n    };\n});\nfunction getColorAttrib(color, attrib) {\n    var alpha = color.a / 255;\n    var str = attrib + '=\"' + color.hex + '\"';\n    return alpha < 1\n        ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n        : str;\n}\nfunction svgCmd(cmd, x, y) {\n    var str = cmd + x;\n    if (typeof y !== 'undefined')\n        str += ' ' + y;\n    return str;\n}\nfunction qrToPath(data, size, margin) {\n    var path = '';\n    var moveBy = 0;\n    var newRow = false;\n    var lineLength = 0;\n    for (var i = 0; i < data.length; i++) {\n        var col = Math.floor(i % size);\n        var row = Math.floor(i / size);\n        if (!col && !newRow)\n            newRow = true;\n        if (data[i]) {\n            lineLength++;\n            if (!(i > 0 && col > 0 && data[i - 1])) {\n                path += newRow\n                    ? svgCmd('M', col + margin, 0.5 + row + margin)\n                    : svgCmd('m', moveBy, 0);\n                moveBy = 0;\n                newRow = false;\n            }\n            if (!(col + 1 < size && data[i + 1])) {\n                path += svgCmd('h', lineLength);\n                lineLength = 0;\n            }\n        }\n        else {\n            moveBy++;\n        }\n    }\n    return path;\n}\nvar render = function render(qrData, options, cb) {\n    var opts = utils$1.getOptions(options);\n    var size = qrData.modules.size;\n    var data = qrData.modules.data;\n    var qrcodesize = size + opts.margin * 2;\n    var bg = !opts.color.light.a\n        ? ''\n        : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n            ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>';\n    var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n        ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n    var viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"';\n    var width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n    var svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n';\n    if (typeof cb === 'function') {\n        cb(null, svgTag);\n    }\n    return svgTag;\n};\nvar svgTag = {\n    render: render\n};\nfunction renderCanvas(renderFunc, canvas, text, opts, cb) {\n    var args = [].slice.call(arguments, 1);\n    var argsNum = args.length;\n    var isLastArgCb = typeof args[argsNum - 1] === 'function';\n    if (!isLastArgCb && !canPromise()) {\n        throw new Error('Callback required as last argument');\n    }\n    if (isLastArgCb) {\n        if (argsNum < 2) {\n            throw new Error('Too few arguments provided');\n        }\n        if (argsNum === 2) {\n            cb = text;\n            text = canvas;\n            canvas = opts = undefined;\n        }\n        else if (argsNum === 3) {\n            if (canvas.getContext && typeof cb === 'undefined') {\n                cb = opts;\n                opts = undefined;\n            }\n            else {\n                cb = opts;\n                opts = text;\n                text = canvas;\n                canvas = undefined;\n            }\n        }\n    }\n    else {\n        if (argsNum < 1) {\n            throw new Error('Too few arguments provided');\n        }\n        if (argsNum === 1) {\n            text = canvas;\n            canvas = opts = undefined;\n        }\n        else if (argsNum === 2 && !canvas.getContext) {\n            opts = text;\n            text = canvas;\n            canvas = undefined;\n        }\n        return new Promise(function (resolve, reject) {\n            try {\n                var data = qrcode.create(text, opts);\n                resolve(renderFunc(data, canvas, opts));\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    }\n    try {\n        var data = qrcode.create(text, opts);\n        cb(null, renderFunc(data, canvas, opts));\n    }\n    catch (e) {\n        cb(e);\n    }\n}\nvar create$1 = qrcode.create;\nvar toCanvas = renderCanvas.bind(null, canvas.render);\nvar toDataURL = renderCanvas.bind(null, canvas.renderToDataURL);\n// only svg for now.\nvar toString_1 = renderCanvas.bind(null, function (data, _, opts) {\n    return svgTag.render(data, opts);\n});\nvar browser = {\n    create: create$1,\n    toCanvas: toCanvas,\n    toDataURL: toDataURL,\n    toString: toString_1\n};\nvar amplifyTotpSetupCss = \".totp-setup{text-align:center;margin-bottom:30px}.totp-setup img{height:128px;width:128px}\";\nvar logger = new _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"Logger\"]('TOTP');\nvar AmplifyTOTPSetup = /** @class */ (function () {\n    function class_1(hostRef) {\n        Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"r\"])(this, hostRef);\n        this.inputProps = {\n            autoFocus: true,\n        };\n        /** Auth state change handler for this component */\n        this.handleAuthStateChange = _helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_6__[\"d\"];\n        /** Used for header text in totp setup component */\n        this.headerText = _Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_HEADER_TEXT;\n        /** Used for customizing the issuer string in the qr code image */\n        this.issuer = _Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_ISSUER;\n        this.code = null;\n        this.setupMessage = null;\n        this.qrCodeInput = null;\n        this.loading = false;\n    }\n    class_1.prototype.componentWillLoad = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        /**\n                         * We didn't use `@Watch` here because it doesn't fire when we go from require-new-password to totp-setup.\n                         * That is because `Auth.completeNewPassword` only changes `user` in place and Watch doesn't detect changes\n                         * unless we make a clone.\n                         */\n                        this.removeHubListener = Object(_helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_6__[\"o\"])(function (authState) {\n                            if (authState === _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_2__[\"A\"].TOTPSetup)\n                                _this.setup();\n                        });\n                        return [4 /*yield*/, this.setup()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.disconnectedCallback = function () {\n        this.removeHubListener && this.removeHubListener(); // stop listening to `onAuthUIStateChange`\n    };\n    class_1.prototype.buildOtpAuthPath = function (user, issuer, secretKey) {\n        return \"otpauth://totp/\" + issuer + \":\" + user.username + \"?secret=\" + secretKey + \"&issuer=\" + issuer;\n    };\n    class_1.prototype.onTOTPEvent = function (event, data, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug('on totp event', event, data);\n                        if (!(event === _constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__[\"S\"] && data === _constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__[\"i\"])) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Object(_auth_helpers_63cc23c0_js__WEBPACK_IMPORTED_MODULE_7__[\"c\"])(user, this.handleAuthStateChange)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.handleTotpInputChange = function (event) {\n        this.setupMessage = null;\n        this.qrCodeInput = event.target.value;\n    };\n    class_1.prototype.generateQRCode = function (codeFromTotp) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        _a = this;\n                        return [4 /*yield*/, browser.toDataURL(codeFromTotp)];\n                    case 1:\n                        _a.qrCodeImageSource = _b.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _b.sent();\n                        Object(_helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_6__[\"a\"])(error_1);\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.setup = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedIssuer, secretKey, error_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // ensure setup is only run once after totp setup is available\n                        if (!this.user || this.user.challengeName !== 'MFA_SETUP' || this.loading)\n                            return [2 /*return*/];\n                        this.setupMessage = null;\n                        encodedIssuer = encodeURI(_aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(this.issuer));\n                        if (!_aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"] || typeof _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"].setupTOTP !== 'function') {\n                            throw new Error(_constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__[\"N\"]);\n                        }\n                        this.loading = true;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4 /*yield*/, _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"].setupTOTP(this.user)];\n                    case 2:\n                        secretKey = _a.sent();\n                        logger.debug('secret key', secretKey);\n                        this.code = this.buildOtpAuthPath(this.user, encodedIssuer, secretKey);\n                        this.generateQRCode(this.code);\n                        return [3 /*break*/, 5];\n                    case 3:\n                        error_2 = _a.sent();\n                        Object(_helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_6__[\"a\"])(error_2);\n                        logger.debug(_aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_SETUP_FAILURE), error_2);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        this.loading = false;\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.verifyTotpToken = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var user, error_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (event) {\n                            event.preventDefault();\n                        }\n                        if (!this.qrCodeInput) {\n                            logger.debug('No TOTP Code provided');\n                            return [2 /*return*/];\n                        }\n                        user = this.user;\n                        if (!_aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"] || typeof _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"].verifyTotpToken !== 'function' || typeof _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"].setPreferredMFA !== 'function') {\n                            throw new Error(_constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__[\"N\"]);\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 5, , 6]);\n                        return [4 /*yield*/, _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"].verifyTotpToken(user, this.qrCodeInput)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_3__[\"Auth\"].setPreferredMFA(user, _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_2__[\"M\"].TOTP)];\n                    case 3:\n                        _a.sent();\n                        this.setupMessage = _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_SUCCESS_MESSAGE);\n                        logger.debug(_aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_SUCCESS_MESSAGE));\n                        return [4 /*yield*/, this.onTOTPEvent(_constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__[\"S\"], _constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_5__[\"i\"], user)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 6];\n                    case 5:\n                        error_3 = _a.sent();\n                        this.setupMessage = _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_SETUP_FAILURE);\n                        logger.error(error_3);\n                        return [3 /*break*/, 6];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    class_1.prototype.render = function () {\n        var _this = this;\n        return (Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"H\"], null, Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"amplify-form-section\", { headerText: _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(this.headerText), submitButtonText: _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_SUBMIT_BUTTON_TEXT), handleSubmit: function (event) { return _this.verifyTotpToken(event); }, loading: this.loading }, Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"div\", { class: \"totp-setup\" }, this.qrCodeImageSource && Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"img\", { src: this.qrCodeImageSource, alt: _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].QR_CODE_ALT) }), Object(_index_3fb5c139_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"])(\"amplify-form-field\", { label: _aws_amplify_core__WEBPACK_IMPORTED_MODULE_1__[\"I18n\"].get(_Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_4__[\"T\"].TOTP_LABEL), inputProps: this.inputProps, fieldId: \"totpCode\", name: \"totpCode\", handleInputChange: function (event) { return _this.handleTotpInputChange(event); } })))));\n    };\n    return class_1;\n}());\nAmplifyTOTPSetup.style = amplifyTotpSetupCss;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9AYXdzLWFtcGxpZnkvdWktY29tcG9uZW50cy9kaXN0L2VzbS1lczUvYW1wbGlmeS1yYWRpby1idXR0b25fMi5lbnRyeS5qcz9lMzUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsU0FBSSxJQUFJLFNBQUk7QUFDL0IsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDMEU7QUFDekI7QUFDeUI7QUFDakM7QUFDc0I7QUFDb0M7QUFDNkI7QUFDakU7QUFDbkM7QUFDNUIsbUNBQW1DLHlDQUF5QyxjQUFjLGNBQWMsV0FBVyxhQUFhLGlDQUFpQywrQkFBK0Isb0JBQW9CLGtCQUFrQjtBQUN0TztBQUNBO0FBQ0EsUUFBUSw0REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBQyxVQUFVLHdCQUF3QixFQUFFLDREQUFDLHlCQUF5QixzTEFBc0wscUJBQXFCLDREQUFDLG1CQUFtQix3QkFBd0I7QUFDdFU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBb0QsV0FBVyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixLQUFLO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCLG1CQUFtQixnQkFBZ0IsYUFBYSxZQUFZO0FBQ3JILGlCQUFpQix3REFBTTtBQUN2QjtBQUNBO0FBQ0EsUUFBUSw0REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0RBQTRCO0FBQ2pFO0FBQ0EsMEJBQTBCLDJEQUFZO0FBQ3RDO0FBQ0Esc0JBQXNCLDJEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDhEQUFtQjtBQUNwRSw4Q0FBOEMseURBQVM7QUFDdkQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3REFBVSxhQUFhLHdEQUFPO0FBQ3RFLDZDQUE2QyxtRUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4REFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNEQUFJO0FBQ3RELDZCQUE2QixzREFBSSxXQUFXLHNEQUFJO0FBQ2hELDRDQUE0Qyx3REFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzREFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFxQjtBQUM3QyxxQ0FBcUMsc0RBQUksS0FBSywyREFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBSSxXQUFXLHNEQUFJLDBDQUEwQyxzREFBSTtBQUM5Riw0Q0FBNEMsd0RBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFJO0FBQ2pEO0FBQ0E7QUFDQSw2Q0FBNkMsc0RBQUksdUJBQXVCLHlEQUFTO0FBQ2pGO0FBQ0E7QUFDQSw0Q0FBNEMsc0RBQUksS0FBSywyREFBWTtBQUNqRSxxQ0FBcUMsc0RBQUksS0FBSywyREFBWTtBQUMxRCw4REFBOEQsd0RBQVUsRUFBRSx3REFBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNEQUFJLEtBQUssMkRBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBQyxDQUFDLG9EQUFJLFFBQVEsNERBQUMsMEJBQTBCLGFBQWEsc0RBQUkseUNBQXlDLHNEQUFJLEtBQUssMkRBQVksMkRBQTJELHFDQUFxQyxFQUFFLHlCQUF5QixFQUFFLDREQUFDLFNBQVMsc0JBQXNCLDRCQUE0Qiw0REFBQyxTQUFTLG1DQUFtQyxzREFBSSxLQUFLLDJEQUFZLGVBQWUsR0FBRyw0REFBQyx3QkFBd0IsUUFBUSxzREFBSSxLQUFLLDJEQUFZLHVIQUF1SCwyQ0FBMkMsRUFBRSxFQUFFO0FBQ2puQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQzhGIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9AYXdzLWFtcGxpZnkvdWktY29tcG9uZW50cy9kaXN0L2VzbS1lczUvYW1wbGlmeS1yYWRpby1idXR0b25fMi5lbnRyeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGgsIEggYXMgSG9zdCB9IGZyb20gJy4vaW5kZXgtM2ZiNWMxMzkuanMnO1xuaW1wb3J0IHsgTG9nZ2VyLCBJMThuIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NvcmUnO1xuaW1wb3J0IHsgTSBhcyBNZmFPcHRpb24sIEEgYXMgQXV0aFN0YXRlIH0gZnJvbSAnLi9hdXRoLXR5cGVzLTc4ZGYzMDRlLmpzJztcbmltcG9ydCB7IEF1dGggfSBmcm9tICdAYXdzLWFtcGxpZnkvYXV0aCc7XG5pbXBvcnQgeyBUIGFzIFRyYW5zbGF0aW9ucyB9IGZyb20gJy4vVHJhbnNsYXRpb25zLWM4MzNmNjYzLmpzJztcbmltcG9ydCB7IFMgYXMgU0VUVVBfVE9UUCwgaSBhcyBTVUNDRVNTLCBOIGFzIE5PX0FVVEhfTU9EVUxFX0ZPVU5EIH0gZnJvbSAnLi9jb25zdGFudHMtZDFhYmU3ZGUuanMnO1xuaW1wb3J0IHsgZCBhcyBkaXNwYXRjaEF1dGhTdGF0ZUNoYW5nZUV2ZW50LCBvIGFzIG9uQXV0aFVJU3RhdGVDaGFuZ2UsIGEgYXMgZGlzcGF0Y2hUb2FzdEh1YkV2ZW50IH0gZnJvbSAnLi9oZWxwZXJzLTA5ZTdjMjc5LmpzJztcbmltcG9ydCB7IGMgYXMgY2hlY2tDb250YWN0IH0gZnJvbSAnLi9hdXRoLWhlbHBlcnMtNjNjYzIzYzAuanMnO1xuaW1wb3J0IGJ1ZmZlciBmcm9tICdidWZmZXInO1xudmFyIGFtcGxpZnlSYWRpb0J1dHRvbkNzcyA9IFwiOmhvc3R7LS1mb250LWZhbWlseTp2YXIoLS1hbXBsaWZ5LWZvbnQtZmFtaWx5KX0ucmFkaW8tYnV0dG9ue2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtwYWRkaW5nOjE2cHg7Zm9udC1zaXplOnZhcigtLWFtcGxpZnktdGV4dC1zbSk7Zm9udC1mYW1pbHk6dmFyKC0tZm9udC1mYW1pbHkpfS5yYWRpby1idXR0b24gaW5wdXR7bWFyZ2luLXJpZ2h0OjEycHh9XCI7XG52YXIgQW1wbGlmeVJhZGlvQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFtcGxpZnlSYWRpb0J1dHRvbihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIC8qKiAoT3B0aW9uYWwpIFRoZSBwbGFjZWhvbGRlciBmb3IgdGhlIGlucHV0IGVsZW1lbnQuICBVc2luZyBoaW50cyBpcyByZWNvbW1lbmRlZCwgYnV0IHBsYWNlaG9sZGVycyBjYW4gYWxzbyBiZSB1c2VmdWwgdG8gY29udmV5IGluZm9ybWF0aW9uIHRvIHVzZXJzLiAqL1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIC8qKiBJZiBgdHJ1ZWAsIHRoZSByYWRpbyBidXR0b24gaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKiogSWYgYHRydWVgLCB0aGUgY2hlY2tib3ggaXMgZGlzYWJsZWQgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBBbXBsaWZ5UmFkaW9CdXR0b24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChoKFwic3BhblwiLCB7IGNsYXNzOiBcInJhZGlvLWJ1dHRvblwiIH0sIGgoXCJpbnB1dFwiLCBPYmplY3QuYXNzaWduKHsgdHlwZTogXCJyYWRpb1wiLCBuYW1lOiB0aGlzLm5hbWUsIHZhbHVlOiB0aGlzLnZhbHVlLCBvbklucHV0OiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlLCBwbGFjZWhvbGRlcjogdGhpcy5wbGFjZWhvbGRlciwgaWQ6IHRoaXMuZmllbGRJZCwgY2hlY2tlZDogdGhpcy5jaGVja2VkLCBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCB9LCB0aGlzLmlucHV0UHJvcHMpKSwgaChcImFtcGxpZnktbGFiZWxcIiwgeyBodG1sRm9yOiB0aGlzLmZpZWxkSWQgfSwgdGhpcy5sYWJlbCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBBbXBsaWZ5UmFkaW9CdXR0b247XG59KCkpO1xuQW1wbGlmeVJhZGlvQnV0dG9uLnN0eWxlID0gYW1wbGlmeVJhZGlvQnV0dG9uQ3NzO1xuLy8gY2FuLXByb21pc2UgaGFzIGEgY3Jhc2ggaW4gc29tZSB2ZXJzaW9ucyBvZiByZWFjdCBuYXRpdmUgdGhhdCBkb250IGhhdmVcbi8vIHN0YW5kYXJkIGdsb2JhbCBvYmplY3RzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc29sZGFpci9ub2RlLXFyY29kZS9pc3N1ZXMvMTU3XG52YXIgY2FuUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgUHJvbWlzZS5wcm90b3R5cGUgJiYgUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcbn07XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbnZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCkge1xuICAgIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgYmUgYXVnbWVudGVkP1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MjsgfSB9O1xuICAgICAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MjtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKTtcbnZhciBLX01BWF9MRU5HVEggPSBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZjtcbmZ1bmN0aW9uIEJ1ZmZlcihhcmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZyk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tKHRoaXMsIGFyZywgb2Zmc2V0LCBsZW5ndGgpO1xufVxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcbiAgICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tlZChsZW5ndGgpIHtcbiAgICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpO1xuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoIHwgMDtcbn1cbmZ1bmN0aW9uIGlzbmFuKHZhbCkge1xuICAgIHJldHVybiB2YWwgIT09IHZhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpIHtcbiAgICB2YXIgYnVmO1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICAgICAgYnVmID0gdGhhdDtcbiAgICAgICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSh0aGF0LCBzaXplKSB7XG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgYnVmW2ldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyh0aGF0LCBzdHJpbmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcpIHwgMDtcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gICAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcpO1xuICAgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgICAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAgICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAgICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgdmFyIGJ1ZjtcbiAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICAgICAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgICAgIGJ1ZiA9IGZyb21BcnJheUxpa2UodGhhdCwgYnVmKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QodGhhdCwgb2JqKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICAgICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBvYmouY29weShidWYsIDAsIDAsIGxlbik7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7XG4gICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgICB2YXIgY29kZVBvaW50O1xuICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgfVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLCBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBieXRlTGVuZ3RoKHN0cmluZykge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICAgIH1cbiAgICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG59XG5mdW5jdGlvbiBmcm9tKHRoYXQsIHZhbHVlLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSk7XG59XG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF0pXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpXG4gICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICBzdGFydCA9IH5+c3RhcnQ7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZDtcbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ICs9IGxlbjtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMClcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICAgICAgc3RhcnQgPSBsZW47XG4gICAgfVxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW47XG4gICAgICAgIGlmIChlbmQgPCAwKVxuICAgICAgICAgICAgZW5kID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgICAgIGVuZCA9IGxlbjtcbiAgICB9XG4gICAgaWYgKGVuZCA8IHN0YXJ0KVxuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICB2YXIgbmV3QnVmO1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgICAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICAgICAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgICAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmO1xufTtcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpXG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApXG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgICAgICB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gICAgaWYgKCF0YXJnZXRTdGFydClcbiAgICAgICAgdGFyZ2V0U3RhcnQgPSAwO1xuICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KVxuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgICBpZiAoZW5kID09PSBzdGFydClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gICAgaWYgKGVuZCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICAgIC8vIEFyZSB3ZSBvb2I/XG4gICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gICAgfVxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICB2YXIgaTtcbiAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAgICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCwgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBsZW47XG59O1xuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgICB9XG4gICAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKTtcbiAgICB9XG4gICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuICAgIGlmICghdmFsKVxuICAgICAgICB2YWwgPSAwO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgICAgICAgPyB2YWxcbiAgICAgICAgICAgIDogbmV3IEJ1ZmZlcih2YWwpO1xuICAgICAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChsaXN0LCBsZW5ndGgpIHtcbiAgICBpZiAoIWlzYXJyYXkobGlzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKG51bGwsIDApO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gYWxsb2NVbnNhZmUobnVsbCwgbGVuZ3RoKTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gICAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59O1xudmFyIGFsbG9jID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICBidWZmZXIuZmlsbCgwKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcbnZhciBmcm9tXzEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEpO1xufTtcbnZhciB0eXBlZGFycmF5QnVmZmVyID0ge1xuICAgIGFsbG9jOiBhbGxvYyxcbiAgICBmcm9tOiBmcm9tXzFcbn07XG52YXIgdG9TSklTRnVuY3Rpb247XG52YXIgQ09ERVdPUkRTX0NPVU5UID0gW1xuICAgIDAsXG4gICAgMjYsIDQ0LCA3MCwgMTAwLCAxMzQsIDE3MiwgMTk2LCAyNDIsIDI5MiwgMzQ2LFxuICAgIDQwNCwgNDY2LCA1MzIsIDU4MSwgNjU1LCA3MzMsIDgxNSwgOTAxLCA5OTEsIDEwODUsXG4gICAgMTE1NiwgMTI1OCwgMTM2NCwgMTQ3NCwgMTU4OCwgMTcwNiwgMTgyOCwgMTkyMSwgMjA1MSwgMjE4NSxcbiAgICAyMzIzLCAyNDY1LCAyNjExLCAyNzYxLCAyODc2LCAzMDM0LCAzMTk2LCAzMzYyLCAzNTMyLCAzNzA2XG5dO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBRUiBDb2RlIHNpemUgZm9yIHRoZSBzcGVjaWZpZWQgdmVyc2lvblxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBzaXplIG9mIFFSIGNvZGVcbiAqL1xudmFyIGdldFN5bWJvbFNpemUgPSBmdW5jdGlvbiBnZXRTeW1ib2xTaXplKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJ2ZXJzaW9uXCIgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgaWYgKHZlcnNpb24gPCAxIHx8IHZlcnNpb24gPiA0MClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInZlcnNpb25cIiBzaG91bGQgYmUgaW4gcmFuZ2UgZnJvbSAxIHRvIDQwJyk7XG4gICAgcmV0dXJuIHZlcnNpb24gKiA0ICsgMTc7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgY29kZXdvcmRzIHVzZWQgdG8gc3RvcmUgZGF0YSBhbmQgRUMgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIERhdGEgbGVuZ3RoIGluIGJpdHNcbiAqL1xudmFyIGdldFN5bWJvbFRvdGFsQ29kZXdvcmRzID0gZnVuY3Rpb24gZ2V0U3ltYm9sVG90YWxDb2Rld29yZHModmVyc2lvbikge1xuICAgIHJldHVybiBDT0RFV09SRFNfQ09VTlRbdmVyc2lvbl07XG59O1xuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIEJvc2UtQ2hhdWRodXJpLUhvY3F1ZW5naGVtXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBkYXRhIFZhbHVlIHRvIGVuY29kZVxuICogQHJldHVybiB7TnVtYmVyfSAgICAgIEVuY29kZWQgdmFsdWVcbiAqL1xudmFyIGdldEJDSERpZ2l0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGlnaXQgPSAwO1xuICAgIHdoaWxlIChkYXRhICE9PSAwKSB7XG4gICAgICAgIGRpZ2l0Kys7XG4gICAgICAgIGRhdGEgPj4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gZGlnaXQ7XG59O1xudmFyIHNldFRvU0pJU0Z1bmN0aW9uID0gZnVuY3Rpb24gc2V0VG9TSklTRnVuY3Rpb24oZikge1xuICAgIGlmICh0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widG9TSklTRnVuY1wiIGlzIG5vdCBhIHZhbGlkIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICB0b1NKSVNGdW5jdGlvbiA9IGY7XG59O1xudmFyIGlzS2FuamlNb2RlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvU0pJU0Z1bmN0aW9uICE9PSAndW5kZWZpbmVkJztcbn07XG52YXIgdG9TSklTID0gZnVuY3Rpb24gdG9TSklTKGthbmppKSB7XG4gICAgcmV0dXJuIHRvU0pJU0Z1bmN0aW9uKGthbmppKTtcbn07XG52YXIgdXRpbHMgPSB7XG4gICAgZ2V0U3ltYm9sU2l6ZTogZ2V0U3ltYm9sU2l6ZSxcbiAgICBnZXRTeW1ib2xUb3RhbENvZGV3b3JkczogZ2V0U3ltYm9sVG90YWxDb2Rld29yZHMsXG4gICAgZ2V0QkNIRGlnaXQ6IGdldEJDSERpZ2l0LFxuICAgIHNldFRvU0pJU0Z1bmN0aW9uOiBzZXRUb1NKSVNGdW5jdGlvbixcbiAgICBpc0thbmppTW9kZUVuYWJsZWQ6IGlzS2FuamlNb2RlRW5hYmxlZCxcbiAgICB0b1NKSVM6IHRvU0pJU1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBiYXNlZGlyLCBtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlID0ge1xuICAgICAgICBwYXRoOiBiYXNlZGlyLFxuICAgICAgICBleHBvcnRzOiB7fSxcbiAgICAgICAgcmVxdWlyZTogZnVuY3Rpb24gKHBhdGgsIGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25qc1JlcXVpcmUoKTtcbiAgICAgICAgfVxuICAgIH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzJyk7XG59XG52YXIgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgZXhwb3J0cy5MID0geyBiaXQ6IDEgfTtcbiAgICBleHBvcnRzLk0gPSB7IGJpdDogMCB9O1xuICAgIGV4cG9ydHMuUSA9IHsgYml0OiAzIH07XG4gICAgZXhwb3J0cy5IID0geyBiaXQ6IDIgfTtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW0gaXMgbm90IGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxjU3RyID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAobGNTdHIpIHtcbiAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5MO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk07XG4gICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0aWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5RO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5IO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gRUMgTGV2ZWw6ICcgKyBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsICYmIHR5cGVvZiBsZXZlbC5iaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBsZXZlbC5iaXQgPj0gMCAmJiBsZXZlbC5iaXQgPCA0O1xuICAgIH07XG4gICAgZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmIChleHBvcnRzLmlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmZ1bmN0aW9uIEJpdEJ1ZmZlcigpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbn1cbkJpdEJ1ZmZlci5wcm90b3R5cGUgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmJ1ZmZlcltidWZJbmRleF0gPj4+ICg3IC0gaW5kZXggJSA4KSkgJiAxKSA9PT0gMTtcbiAgICB9LFxuICAgIHB1dDogZnVuY3Rpb24gKG51bSwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucHV0Qml0KCgobnVtID4+PiAobGVuZ3RoIC0gaSAtIDEpKSAmIDEpID09PSAxKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TGVuZ3RoSW5CaXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9LFxuICAgIHB1dEJpdDogZnVuY3Rpb24gKGJpdCkge1xuICAgICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gOCk7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbYnVmSW5kZXhdIHw9ICgweDgwID4+PiAodGhpcy5sZW5ndGggJSA4KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG59O1xudmFyIGJpdEJ1ZmZlciA9IEJpdEJ1ZmZlcjtcbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGhhbmRsZSBRUiBDb2RlIHN5bWJvbCBtb2R1bGVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgU3ltYm9sIHNpemVcbiAqL1xuZnVuY3Rpb24gQml0TWF0cml4KHNpemUpIHtcbiAgICBpZiAoIXNpemUgfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRNYXRyaXggc2l6ZSBtdXN0IGJlIGRlZmluZWQgYW5kIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kYXRhID0gdHlwZWRhcnJheUJ1ZmZlci5hbGxvYyhzaXplICogc2l6ZSk7XG4gICAgdGhpcy5yZXNlcnZlZEJpdCA9IHR5cGVkYXJyYXlCdWZmZXIuYWxsb2Moc2l6ZSAqIHNpemUpO1xufVxuLyoqXG4gKiBTZXQgYml0IHZhbHVlIGF0IHNwZWNpZmllZCBsb2NhdGlvblxuICogSWYgcmVzZXJ2ZWQgZmxhZyBpcyBzZXQsIHRoaXMgYml0IHdpbGwgYmUgaWdub3JlZCBkdXJpbmcgbWFza2luZyBwcm9jZXNzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9ICByb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSAgY29sXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlc2VydmVkXG4gKi9cbkJpdE1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHJvdywgY29sLCB2YWx1ZSwgcmVzZXJ2ZWQpIHtcbiAgICB2YXIgaW5kZXggPSByb3cgKiB0aGlzLnNpemUgKyBjb2w7XG4gICAgdGhpcy5kYXRhW2luZGV4XSA9IHZhbHVlO1xuICAgIGlmIChyZXNlcnZlZClcbiAgICAgICAgdGhpcy5yZXNlcnZlZEJpdFtpbmRleF0gPSB0cnVlO1xufTtcbi8qKlxuICogUmV0dXJucyBiaXQgdmFsdWUgYXQgc3BlY2lmaWVkIGxvY2F0aW9uXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgcm93XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBjb2xcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtyb3cgKiB0aGlzLnNpemUgKyBjb2xdO1xufTtcbi8qKlxuICogQXBwbGllcyB4b3Igb3BlcmF0b3IgYXQgc3BlY2lmaWVkIGxvY2F0aW9uXG4gKiAodXNlZCBkdXJpbmcgbWFza2luZyBwcm9jZXNzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSAgcm93XG4gKiBAcGFyYW0ge051bWJlcn0gIGNvbFxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICovXG5CaXRNYXRyaXgucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChyb3csIGNvbCwgdmFsdWUpIHtcbiAgICB0aGlzLmRhdGFbcm93ICogdGhpcy5zaXplICsgY29sXSBePSB2YWx1ZTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGJpdCBhdCBzcGVjaWZpZWQgbG9jYXRpb24gaXMgcmVzZXJ2ZWRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gICByb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQml0TWF0cml4LnByb3RvdHlwZS5pc1Jlc2VydmVkID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzZXJ2ZWRCaXRbcm93ICogdGhpcy5zaXplICsgY29sXTtcbn07XG52YXIgYml0TWF0cml4ID0gQml0TWF0cml4O1xudmFyIGFsaWdubWVudFBhdHRlcm4gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogQWxpZ25tZW50IHBhdHRlcm4gYXJlIGZpeGVkIHJlZmVyZW5jZSBwYXR0ZXJuIGluIGRlZmluZWQgcG9zaXRpb25zXG4gICAgICogaW4gYSBtYXRyaXggc3ltYm9sb2d5LCB3aGljaCBlbmFibGVzIHRoZSBkZWNvZGUgc29mdHdhcmUgdG8gcmUtc3luY2hyb25pc2VcbiAgICAgKiB0aGUgY29vcmRpbmF0ZSBtYXBwaW5nIG9mIHRoZSBpbWFnZSBtb2R1bGVzIGluIHRoZSBldmVudCBvZiBtb2RlcmF0ZSBhbW91bnRzXG4gICAgICogb2YgZGlzdG9ydGlvbiBvZiB0aGUgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBBbGlnbm1lbnQgcGF0dGVybnMgYXJlIHByZXNlbnQgb25seSBpbiBRUiBDb2RlIHN5bWJvbHMgb2YgdmVyc2lvbiAyIG9yIGxhcmdlclxuICAgICAqIGFuZCB0aGVpciBudW1iZXIgZGVwZW5kcyBvbiB0aGUgc3ltYm9sIHZlcnNpb24uXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbFNpemUgPSB1dGlscy5nZXRTeW1ib2xTaXplO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcm93L2NvbHVtbiBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyIG1vZHVsZSBvZiBlYWNoIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICogZm9yIHRoZSBzcGVjaWZpZWQgUVIgQ29kZSB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogVGhlIGFsaWdubWVudCBwYXR0ZXJucyBhcmUgcG9zaXRpb25lZCBzeW1tZXRyaWNhbGx5IG9uIGVpdGhlciBzaWRlIG9mIHRoZSBkaWFnb25hbFxuICAgICAqIHJ1bm5pbmcgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzeW1ib2wgdG8gdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBTaW5jZSBwb3NpdGlvbnMgYXJlIHNpbW1ldHJpY2FsIG9ubHkgaGFsZiBvZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHJldHVybmVkLlxuICAgICAqIEVhY2ggaXRlbSBvZiB0aGUgYXJyYXkgd2lsbCByZXByZXNlbnQgaW4gdHVybiB0aGUgeCBhbmQgeSBjb29yZGluYXRlLlxuICAgICAqIEBzZWUge0BsaW5rIGdldFBvc2l0aW9uc31cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2YgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGV4cG9ydHMuZ2V0Um93Q29sQ29vcmRzID0gZnVuY3Rpb24gZ2V0Um93Q29sQ29vcmRzKHZlcnNpb24pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHZhciBwb3NDb3VudCA9IE1hdGguZmxvb3IodmVyc2lvbiAvIDcpICsgMjtcbiAgICAgICAgdmFyIHNpemUgPSBnZXRTeW1ib2xTaXplKHZlcnNpb24pO1xuICAgICAgICB2YXIgaW50ZXJ2YWxzID0gc2l6ZSA9PT0gMTQ1ID8gMjYgOiBNYXRoLmNlaWwoKHNpemUgLSAxMykgLyAoMiAqIHBvc0NvdW50IC0gMikpICogMjtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtzaXplIC0gN107IC8vIExhc3QgY29vcmQgaXMgYWx3YXlzIChzaXplIC0gNylcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb3NDb3VudCAtIDE7IGkrKykge1xuICAgICAgICAgICAgcG9zaXRpb25zW2ldID0gcG9zaXRpb25zW2kgLSAxXSAtIGludGVydmFscztcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbnMucHVzaCg2KTsgLy8gRmlyc3QgY29vcmQgaXMgYWx3YXlzIDZcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9ucyBvZiBlYWNoIGFsaWdubWVudCBwYXR0ZXJuLlxuICAgICAqIEVhY2ggYXJyYXkncyBlbGVtZW50IHJlcHJlc2VudCB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBwYXR0ZXJuIGFzICh4LCB5KSBjb29yZGluYXRlc1xuICAgICAqXG4gICAgICogQ29vcmRpbmF0ZXMgYXJlIGNhbGN1bGF0ZWQgZXhwYW5kaW5nIHRoZSByb3cvY29sdW1uIGNvb3JkaW5hdGVzIHJldHVybmVkIGJ5IHtAbGluayBnZXRSb3dDb2xDb29yZHN9XG4gICAgICogYW5kIGZpbHRlcmluZyBvdXQgdGhlIGl0ZW1zIHRoYXQgb3ZlcmxhcHMgd2l0aCBmaW5kZXIgcGF0dGVyblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBGb3IgYSBWZXJzaW9uIDcgc3ltYm9sIHtAbGluayBnZXRSb3dDb2xDb29yZHN9IHJldHVybnMgdmFsdWVzIDYsIDIyIGFuZCAzOC5cbiAgICAgKiBUaGUgYWxpZ25tZW50IHBhdHRlcm5zLCB0aGVyZWZvcmUsIGFyZSB0byBiZSBjZW50ZXJlZCBvbiAocm93LCBjb2x1bW4pXG4gICAgICogcG9zaXRpb25zICg2LDIyKSwgKDIyLDYpLCAoMjIsMjIpLCAoMjIsMzgpLCAoMzgsMjIpLCAoMzgsMzgpLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgY29vcmRpbmF0ZXMgKDYsNiksICg2LDM4KSwgKDM4LDYpIGFyZSBvY2N1cGllZCBieSBmaW5kZXIgcGF0dGVybnNcbiAgICAgKiBhbmQgYXJlIG5vdCB0aGVyZWZvcmUgdXNlZCBmb3IgYWxpZ25tZW50IHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogdmFyIHBvcyA9IGdldFBvc2l0aW9ucyg3KVxuICAgICAqIC8vIFtbNiwyMl0sIFsyMiw2XSwgWzIyLDIyXSwgWzIyLDM4XSwgWzM4LDIyXSwgWzM4LDM4XV1cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2YgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBleHBvcnRzLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyh2ZXJzaW9uKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICAgICAgdmFyIHBvcyA9IGV4cG9ydHMuZ2V0Um93Q29sQ29vcmRzKHZlcnNpb24pO1xuICAgICAgICB2YXIgcG9zTGVuZ3RoID0gcG9zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3NMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgaWYgcG9zaXRpb24gaXMgb2NjdXBpZWQgYnkgZmluZGVyIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgaWYgKChpID09PSAwICYmIGogPT09IDApIHx8IC8vIHRvcC1sZWZ0XG4gICAgICAgICAgICAgICAgICAgIChpID09PSAwICYmIGogPT09IHBvc0xlbmd0aCAtIDEpIHx8IC8vIGJvdHRvbS1sZWZ0XG4gICAgICAgICAgICAgICAgICAgIChpID09PSBwb3NMZW5ndGggLSAxICYmIGogPT09IDApKSB7IC8vIHRvcC1yaWdodFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW3Bvc1tpXSwgcG9zW2pdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9O1xufSk7XG52YXIgZ2V0U3ltYm9sU2l6ZSQxID0gdXRpbHMuZ2V0U3ltYm9sU2l6ZTtcbnZhciBGSU5ERVJfUEFUVEVSTl9TSVpFID0gNztcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBwb3NpdGlvbnMgb2YgZWFjaCBmaW5kZXIgcGF0dGVybi5cbiAqIEVhY2ggYXJyYXkncyBlbGVtZW50IHJlcHJlc2VudCB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIHBhdHRlcm4gYXMgKHgsIHkpIGNvb3JkaW5hdGVzXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIEFycmF5IG9mIGNvb3JkaW5hdGVzXG4gKi9cbnZhciBnZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnModmVyc2lvbikge1xuICAgIHZhciBzaXplID0gZ2V0U3ltYm9sU2l6ZSQxKHZlcnNpb24pO1xuICAgIHJldHVybiBbXG4gICAgICAgIC8vIHRvcC1sZWZ0XG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgLy8gdG9wLXJpZ2h0XG4gICAgICAgIFtzaXplIC0gRklOREVSX1BBVFRFUk5fU0laRSwgMF0sXG4gICAgICAgIC8vIGJvdHRvbS1sZWZ0XG4gICAgICAgIFswLCBzaXplIC0gRklOREVSX1BBVFRFUk5fU0laRV1cbiAgICBdO1xufTtcbnZhciBmaW5kZXJQYXR0ZXJuID0ge1xuICAgIGdldFBvc2l0aW9uczogZ2V0UG9zaXRpb25zXG59O1xudmFyIG1hc2tQYXR0ZXJuID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8qKlxuICAgICAqIERhdGEgbWFzayBwYXR0ZXJuIHJlZmVyZW5jZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZXhwb3J0cy5QYXR0ZXJucyA9IHtcbiAgICAgICAgUEFUVEVSTjAwMDogMCxcbiAgICAgICAgUEFUVEVSTjAwMTogMSxcbiAgICAgICAgUEFUVEVSTjAxMDogMixcbiAgICAgICAgUEFUVEVSTjAxMTogMyxcbiAgICAgICAgUEFUVEVSTjEwMDogNCxcbiAgICAgICAgUEFUVEVSTjEwMTogNSxcbiAgICAgICAgUEFUVEVSTjExMDogNixcbiAgICAgICAgUEFUVEVSTjExMTogN1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2VpZ2h0ZWQgcGVuYWx0eSBzY29yZXMgZm9yIHRoZSB1bmRlc2lyYWJsZSBmZWF0dXJlc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIFBlbmFsdHlTY29yZXMgPSB7XG4gICAgICAgIE4xOiAzLFxuICAgICAgICBOMjogMyxcbiAgICAgICAgTjM6IDQwLFxuICAgICAgICBONDogMTBcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG1hc2sgcGF0dGVybiB2YWx1ZSBpcyB2YWxpZFxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgbWFzayAgICBNYXNrIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIHRydWUgaWYgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQobWFzaykge1xuICAgICAgICByZXR1cm4gbWFzayAhPSBudWxsICYmIG1hc2sgIT09ICcnICYmICFpc05hTihtYXNrKSAmJiBtYXNrID49IDAgJiYgbWFzayA8PSA3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtYXNrIHBhdHRlcm4gZnJvbSBhIHZhbHVlLlxuICAgICAqIElmIHZhbHVlIGlzIG5vdCB2YWxpZCwgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICBNYXNrIHBhdHRlcm4gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgVmFsaWQgbWFzayBwYXR0ZXJuIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZCh2YWx1ZSkgPyBwYXJzZUludCh2YWx1ZSwgMTApIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBGaW5kIGFkamFjZW50IG1vZHVsZXMgaW4gcm93L2NvbHVtbiB3aXRoIHRoZSBzYW1lIGNvbG9yXG4gICAgKiBhbmQgYXNzaWduIGEgcGVuYWx0eSB2YWx1ZS5cbiAgICAqXG4gICAgKiBQb2ludHM6IE4xICsgaVxuICAgICogaSBpcyB0aGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBudW1iZXIgb2YgYWRqYWNlbnQgbW9kdWxlcyBvZiB0aGUgc2FtZSBjb2xvciBleGNlZWRzIDVcbiAgICAqL1xuICAgIGV4cG9ydHMuZ2V0UGVuYWx0eU4xID0gZnVuY3Rpb24gZ2V0UGVuYWx0eU4xKGRhdGEpIHtcbiAgICAgICAgdmFyIHNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIHZhciBwb2ludHMgPSAwO1xuICAgICAgICB2YXIgc2FtZUNvdW50Q29sID0gMDtcbiAgICAgICAgdmFyIHNhbWVDb3VudFJvdyA9IDA7XG4gICAgICAgIHZhciBsYXN0Q29sID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RSb3cgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBzaXplOyByb3crKykge1xuICAgICAgICAgICAgc2FtZUNvdW50Q29sID0gc2FtZUNvdW50Um93ID0gMDtcbiAgICAgICAgICAgIGxhc3RDb2wgPSBsYXN0Um93ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGRhdGEuZ2V0KHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlID09PSBsYXN0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVDb3VudENvbCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVDb3VudENvbCA+PSA1KVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICs9IFBlbmFsdHlTY29yZXMuTjEgKyAoc2FtZUNvdW50Q29sIC0gNSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb2wgPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVDb3VudENvbCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZHVsZSA9IGRhdGEuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlID09PSBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVDb3VudFJvdysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVDb3VudFJvdyA+PSA1KVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICs9IFBlbmFsdHlTY29yZXMuTjEgKyAoc2FtZUNvdW50Um93IC0gNSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSb3cgPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVDb3VudFJvdyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNhbWVDb3VudENvbCA+PSA1KVxuICAgICAgICAgICAgICAgIHBvaW50cyArPSBQZW5hbHR5U2NvcmVzLk4xICsgKHNhbWVDb3VudENvbCAtIDUpO1xuICAgICAgICAgICAgaWYgKHNhbWVDb3VudFJvdyA+PSA1KVxuICAgICAgICAgICAgICAgIHBvaW50cyArPSBQZW5hbHR5U2NvcmVzLk4xICsgKHNhbWVDb3VudFJvdyAtIDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIDJ4MiBibG9ja3Mgd2l0aCB0aGUgc2FtZSBjb2xvciBhbmQgYXNzaWduIGEgcGVuYWx0eSB2YWx1ZVxuICAgICAqXG4gICAgICogUG9pbnRzOiBOMiAqIChtIC0gMSkgKiAobiAtIDEpXG4gICAgICovXG4gICAgZXhwb3J0cy5nZXRQZW5hbHR5TjIgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjIoZGF0YSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgdmFyIHBvaW50cyA9IDA7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHNpemUgLSAxOyByb3crKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgc2l6ZSAtIDE7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBkYXRhLmdldChyb3csIGNvbCkgK1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmdldChyb3csIGNvbCArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5nZXQocm93ICsgMSwgY29sKSArXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZ2V0KHJvdyArIDEsIGNvbCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09PSA0IHx8IGxhc3QgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHMgKiBQZW5hbHR5U2NvcmVzLk4yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCAxOjE6MzoxOjEgcmF0aW8gKGRhcms6bGlnaHQ6ZGFyazpsaWdodDpkYXJrKSBwYXR0ZXJuIGluIHJvdy9jb2x1bW4sXG4gICAgICogcHJlY2VkZWQgb3IgZm9sbG93ZWQgYnkgbGlnaHQgYXJlYSA0IG1vZHVsZXMgd2lkZVxuICAgICAqXG4gICAgICogUG9pbnRzOiBOMyAqIG51bWJlciBvZiBwYXR0ZXJuIGZvdW5kXG4gICAgICovXG4gICAgZXhwb3J0cy5nZXRQZW5hbHR5TjMgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjMoZGF0YSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgdmFyIHBvaW50cyA9IDA7XG4gICAgICAgIHZhciBiaXRzQ29sID0gMDtcbiAgICAgICAgdmFyIGJpdHNSb3cgPSAwO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBzaXplOyByb3crKykge1xuICAgICAgICAgICAgYml0c0NvbCA9IGJpdHNSb3cgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgc2l6ZTsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBiaXRzQ29sID0gKChiaXRzQ29sIDw8IDEpICYgMHg3RkYpIHwgZGF0YS5nZXQocm93LCBjb2wpO1xuICAgICAgICAgICAgICAgIGlmIChjb2wgPj0gMTAgJiYgKGJpdHNDb2wgPT09IDB4NUQwIHx8IGJpdHNDb2wgPT09IDB4MDVEKSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzKys7XG4gICAgICAgICAgICAgICAgYml0c1JvdyA9ICgoYml0c1JvdyA8PCAxKSAmIDB4N0ZGKSB8IGRhdGEuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICBpZiAoY29sID49IDEwICYmIChiaXRzUm93ID09PSAweDVEMCB8fCBiaXRzUm93ID09PSAweDA1RCkpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHMgKiBQZW5hbHR5U2NvcmVzLk4zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHByb3BvcnRpb24gb2YgZGFyayBtb2R1bGVzIGluIGVudGlyZSBzeW1ib2xcbiAgICAgKlxuICAgICAqIFBvaW50czogTjQgKiBrXG4gICAgICpcbiAgICAgKiBrIGlzIHRoZSByYXRpbmcgb2YgdGhlIGRldmlhdGlvbiBvZiB0aGUgcHJvcG9ydGlvbiBvZiBkYXJrIG1vZHVsZXNcbiAgICAgKiBpbiB0aGUgc3ltYm9sIGZyb20gNTAlIGluIHN0ZXBzIG9mIDUlXG4gICAgICovXG4gICAgZXhwb3J0cy5nZXRQZW5hbHR5TjQgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjQoZGF0YSkge1xuICAgICAgICB2YXIgZGFya0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG1vZHVsZXNDb3VudCA9IGRhdGEuZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlc0NvdW50OyBpKyspXG4gICAgICAgICAgICBkYXJrQ291bnQgKz0gZGF0YS5kYXRhW2ldO1xuICAgICAgICB2YXIgayA9IE1hdGguYWJzKE1hdGguY2VpbCgoZGFya0NvdW50ICogMTAwIC8gbW9kdWxlc0NvdW50KSAvIDUpIC0gMTApO1xuICAgICAgICByZXR1cm4gayAqIFBlbmFsdHlTY29yZXMuTjQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWFzayB2YWx1ZSBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNrUGF0dGVybiBQYXR0ZXJuIHJlZmVyZW5jZSB2YWx1ZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaSAgICAgICAgICAgUm93XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBqICAgICAgICAgICBDb2x1bW5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIE1hc2sgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXNrQXQobWFza1BhdHRlcm4sIGksIGopIHtcbiAgICAgICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMDA6IHJldHVybiAoaSArIGopICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMDAxOiByZXR1cm4gaSAlIDIgPT09IDA7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjAxMDogcmV0dXJuIGogJSAzID09PSAwO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMTE6IHJldHVybiAoaSArIGopICUgMyA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMTAwOiByZXR1cm4gKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMTAxOiByZXR1cm4gKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMyA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMTEwOiByZXR1cm4gKChpICogaikgJSAyICsgKGkgKiBqKSAlIDMpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMTExOiByZXR1cm4gKChpICogaikgJSAzICsgKGkgKyBqKSAlIDIpICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignYmFkIG1hc2tQYXR0ZXJuOicgKyBtYXNrUGF0dGVybik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBtYXNrIHBhdHRlcm4gdG8gYSBCaXRNYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgcGF0dGVybiBQYXR0ZXJuIHJlZmVyZW5jZSBudW1iZXJcbiAgICAgKiBAcGFyYW0gIHtCaXRNYXRyaXh9IGRhdGEgICAgQml0TWF0cml4IGRhdGFcbiAgICAgKi9cbiAgICBleHBvcnRzLmFwcGx5TWFzayA9IGZ1bmN0aW9uIGFwcGx5TWFzayhwYXR0ZXJuLCBkYXRhKSB7XG4gICAgICAgIHZhciBzaXplID0gZGF0YS5zaXplO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBzaXplOyBjb2wrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5pc1Jlc2VydmVkKHJvdywgY29sKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGF0YS54b3Iocm93LCBjb2wsIGdldE1hc2tBdChwYXR0ZXJuLCByb3csIGNvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IG1hc2sgcGF0dGVybiBmb3IgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Qml0TWF0cml4fSBkYXRhXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBNYXNrIHBhdHRlcm4gcmVmZXJlbmNlIG51bWJlclxuICAgICAqL1xuICAgIGV4cG9ydHMuZ2V0QmVzdE1hc2sgPSBmdW5jdGlvbiBnZXRCZXN0TWFzayhkYXRhLCBzZXR1cEZvcm1hdEZ1bmMpIHtcbiAgICAgICAgdmFyIG51bVBhdHRlcm5zID0gT2JqZWN0LmtleXMoZXhwb3J0cy5QYXR0ZXJucykubGVuZ3RoO1xuICAgICAgICB2YXIgYmVzdFBhdHRlcm4gPSAwO1xuICAgICAgICB2YXIgbG93ZXJQZW5hbHR5ID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgbnVtUGF0dGVybnM7IHArKykge1xuICAgICAgICAgICAgc2V0dXBGb3JtYXRGdW5jKHApO1xuICAgICAgICAgICAgZXhwb3J0cy5hcHBseU1hc2socCwgZGF0YSk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVuYWx0eVxuICAgICAgICAgICAgdmFyIHBlbmFsdHkgPSBleHBvcnRzLmdldFBlbmFsdHlOMShkYXRhKSArXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5nZXRQZW5hbHR5TjIoZGF0YSkgK1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuZ2V0UGVuYWx0eU4zKGRhdGEpICtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmdldFBlbmFsdHlONChkYXRhKTtcbiAgICAgICAgICAgIC8vIFVuZG8gcHJldmlvdXNseSBhcHBsaWVkIG1hc2tcbiAgICAgICAgICAgIGV4cG9ydHMuYXBwbHlNYXNrKHAsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKHBlbmFsdHkgPCBsb3dlclBlbmFsdHkpIHtcbiAgICAgICAgICAgICAgICBsb3dlclBlbmFsdHkgPSBwZW5hbHR5O1xuICAgICAgICAgICAgICAgIGJlc3RQYXR0ZXJuID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdFBhdHRlcm47XG4gICAgfTtcbn0pO1xudmFyIEVDX0JMT0NLU19UQUJMRSA9IFtcbiAgICAvLyBMICBNICBRICBIXG4gICAgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDIsIDIsXG4gICAgMSwgMiwgMiwgNCxcbiAgICAxLCAyLCA0LCA0LFxuICAgIDIsIDQsIDQsIDQsXG4gICAgMiwgNCwgNiwgNSxcbiAgICAyLCA0LCA2LCA2LFxuICAgIDIsIDUsIDgsIDgsXG4gICAgNCwgNSwgOCwgOCxcbiAgICA0LCA1LCA4LCAxMSxcbiAgICA0LCA4LCAxMCwgMTEsXG4gICAgNCwgOSwgMTIsIDE2LFxuICAgIDQsIDksIDE2LCAxNixcbiAgICA2LCAxMCwgMTIsIDE4LFxuICAgIDYsIDEwLCAxNywgMTYsXG4gICAgNiwgMTEsIDE2LCAxOSxcbiAgICA2LCAxMywgMTgsIDIxLFxuICAgIDcsIDE0LCAyMSwgMjUsXG4gICAgOCwgMTYsIDIwLCAyNSxcbiAgICA4LCAxNywgMjMsIDI1LFxuICAgIDksIDE3LCAyMywgMzQsXG4gICAgOSwgMTgsIDI1LCAzMCxcbiAgICAxMCwgMjAsIDI3LCAzMixcbiAgICAxMiwgMjEsIDI5LCAzNSxcbiAgICAxMiwgMjMsIDM0LCAzNyxcbiAgICAxMiwgMjUsIDM0LCA0MCxcbiAgICAxMywgMjYsIDM1LCA0MixcbiAgICAxNCwgMjgsIDM4LCA0NSxcbiAgICAxNSwgMjksIDQwLCA0OCxcbiAgICAxNiwgMzEsIDQzLCA1MSxcbiAgICAxNywgMzMsIDQ1LCA1NCxcbiAgICAxOCwgMzUsIDQ4LCA1NyxcbiAgICAxOSwgMzcsIDUxLCA2MCxcbiAgICAxOSwgMzgsIDUzLCA2MyxcbiAgICAyMCwgNDAsIDU2LCA2NixcbiAgICAyMSwgNDMsIDU5LCA3MCxcbiAgICAyMiwgNDUsIDYyLCA3NCxcbiAgICAyNCwgNDcsIDY1LCA3NyxcbiAgICAyNSwgNDksIDY4LCA4MVxuXTtcbnZhciBFQ19DT0RFV09SRFNfVEFCTEUgPSBbXG4gICAgLy8gTCAgTSAgUSAgSFxuICAgIDcsIDEwLCAxMywgMTcsXG4gICAgMTAsIDE2LCAyMiwgMjgsXG4gICAgMTUsIDI2LCAzNiwgNDQsXG4gICAgMjAsIDM2LCA1MiwgNjQsXG4gICAgMjYsIDQ4LCA3MiwgODgsXG4gICAgMzYsIDY0LCA5NiwgMTEyLFxuICAgIDQwLCA3MiwgMTA4LCAxMzAsXG4gICAgNDgsIDg4LCAxMzIsIDE1NixcbiAgICA2MCwgMTEwLCAxNjAsIDE5MixcbiAgICA3MiwgMTMwLCAxOTIsIDIyNCxcbiAgICA4MCwgMTUwLCAyMjQsIDI2NCxcbiAgICA5NiwgMTc2LCAyNjAsIDMwOCxcbiAgICAxMDQsIDE5OCwgMjg4LCAzNTIsXG4gICAgMTIwLCAyMTYsIDMyMCwgMzg0LFxuICAgIDEzMiwgMjQwLCAzNjAsIDQzMixcbiAgICAxNDQsIDI4MCwgNDA4LCA0ODAsXG4gICAgMTY4LCAzMDgsIDQ0OCwgNTMyLFxuICAgIDE4MCwgMzM4LCA1MDQsIDU4OCxcbiAgICAxOTYsIDM2NCwgNTQ2LCA2NTAsXG4gICAgMjI0LCA0MTYsIDYwMCwgNzAwLFxuICAgIDIyNCwgNDQyLCA2NDQsIDc1MCxcbiAgICAyNTIsIDQ3NiwgNjkwLCA4MTYsXG4gICAgMjcwLCA1MDQsIDc1MCwgOTAwLFxuICAgIDMwMCwgNTYwLCA4MTAsIDk2MCxcbiAgICAzMTIsIDU4OCwgODcwLCAxMDUwLFxuICAgIDMzNiwgNjQ0LCA5NTIsIDExMTAsXG4gICAgMzYwLCA3MDAsIDEwMjAsIDEyMDAsXG4gICAgMzkwLCA3MjgsIDEwNTAsIDEyNjAsXG4gICAgNDIwLCA3ODQsIDExNDAsIDEzNTAsXG4gICAgNDUwLCA4MTIsIDEyMDAsIDE0NDAsXG4gICAgNDgwLCA4NjgsIDEyOTAsIDE1MzAsXG4gICAgNTEwLCA5MjQsIDEzNTAsIDE2MjAsXG4gICAgNTQwLCA5ODAsIDE0NDAsIDE3MTAsXG4gICAgNTcwLCAxMDM2LCAxNTMwLCAxODAwLFxuICAgIDU3MCwgMTA2NCwgMTU5MCwgMTg5MCxcbiAgICA2MDAsIDExMjAsIDE2ODAsIDE5ODAsXG4gICAgNjMwLCAxMjA0LCAxNzcwLCAyMTAwLFxuICAgIDY2MCwgMTI2MCwgMTg2MCwgMjIyMCxcbiAgICA3MjAsIDEzMTYsIDE5NTAsIDIzMTAsXG4gICAgNzUwLCAxMzcyLCAyMDQwLCAyNDMwXG5dO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBibG9jayB0aGF0IHRoZSBRUiBDb2RlIHNob3VsZCBjb250YWluXG4gKiBmb3IgdGhlIHNwZWNpZmllZCB2ZXJzaW9uIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXG4gKi9cbnZhciBnZXRCbG9ja3NDb3VudCA9IGZ1bmN0aW9uIGdldEJsb2Nrc0NvdW50KHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsJDEpIHtcbiAgICBzd2l0Y2ggKGVycm9yQ29ycmVjdGlvbkxldmVsJDEpIHtcbiAgICAgICAgY2FzZSBlcnJvckNvcnJlY3Rpb25MZXZlbC5MOlxuICAgICAgICAgICAgcmV0dXJuIEVDX0JMT0NLU19UQUJMRVsodmVyc2lvbiAtIDEpICogNCArIDBdO1xuICAgICAgICBjYXNlIGVycm9yQ29ycmVjdGlvbkxldmVsLk06XG4gICAgICAgICAgICByZXR1cm4gRUNfQkxPQ0tTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMV07XG4gICAgICAgIGNhc2UgZXJyb3JDb3JyZWN0aW9uTGV2ZWwuUTpcbiAgICAgICAgICAgIHJldHVybiBFQ19CTE9DS1NfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAyXTtcbiAgICAgICAgY2FzZSBlcnJvckNvcnJlY3Rpb25MZXZlbC5IOlxuICAgICAgICAgICAgcmV0dXJuIEVDX0JMT0NLU19UQUJMRVsodmVyc2lvbiAtIDEpICogNCArIDNdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMgdG8gdXNlIGZvciB0aGUgc3BlY2lmaWVkXG4gKiB2ZXJzaW9uIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXG4gKi9cbnZhciBnZXRUb3RhbENvZGV3b3Jkc0NvdW50ID0gZnVuY3Rpb24gZ2V0VG90YWxDb2Rld29yZHNDb3VudCh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCQxKSB7XG4gICAgc3dpdGNoIChlcnJvckNvcnJlY3Rpb25MZXZlbCQxKSB7XG4gICAgICAgIGNhc2UgZXJyb3JDb3JyZWN0aW9uTGV2ZWwuTDpcbiAgICAgICAgICAgIHJldHVybiBFQ19DT0RFV09SRFNfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAwXTtcbiAgICAgICAgY2FzZSBlcnJvckNvcnJlY3Rpb25MZXZlbC5NOlxuICAgICAgICAgICAgcmV0dXJuIEVDX0NPREVXT1JEU19UQUJMRVsodmVyc2lvbiAtIDEpICogNCArIDFdO1xuICAgICAgICBjYXNlIGVycm9yQ29ycmVjdGlvbkxldmVsLlE6XG4gICAgICAgICAgICByZXR1cm4gRUNfQ09ERVdPUkRTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMl07XG4gICAgICAgIGNhc2UgZXJyb3JDb3JyZWN0aW9uTGV2ZWwuSDpcbiAgICAgICAgICAgIHJldHVybiBFQ19DT0RFV09SRFNfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbnZhciBlcnJvckNvcnJlY3Rpb25Db2RlID0ge1xuICAgIGdldEJsb2Nrc0NvdW50OiBnZXRCbG9ja3NDb3VudCxcbiAgICBnZXRUb3RhbENvZGV3b3Jkc0NvdW50OiBnZXRUb3RhbENvZGV3b3Jkc0NvdW50XG59O1xudmFyIEVYUF9UQUJMRSA9IHR5cGVkYXJyYXlCdWZmZXIuYWxsb2MoNTEyKTtcbnZhciBMT0dfVEFCTEUgPSB0eXBlZGFycmF5QnVmZmVyLmFsbG9jKDI1Nik7XG4oZnVuY3Rpb24gaW5pdFRhYmxlcygpIHtcbiAgICB2YXIgeCA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkrKykge1xuICAgICAgICBFWFBfVEFCTEVbaV0gPSB4O1xuICAgICAgICBMT0dfVEFCTEVbeF0gPSBpO1xuICAgICAgICB4IDw8PSAxOyAvLyBtdWx0aXBseSBieSAyXG4gICAgICAgIC8vIFRoZSBRUiBjb2RlIHNwZWNpZmljYXRpb24gc2F5cyB0byB1c2UgYnl0ZS13aXNlIG1vZHVsbyAxMDAwMTExMDEgYXJpdGhtZXRpYy5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdoZW4gYSBudW1iZXIgaXMgMjU2IG9yIGxhcmdlciwgaXQgc2hvdWxkIGJlIFhPUmVkIHdpdGggMHgxMUQuXG4gICAgICAgIGlmICh4ICYgMHgxMDApIHsgLy8gc2ltaWxhciB0byB4ID49IDI1NiwgYnV0IGEgbG90IGZhc3RlciAoYmVjYXVzZSAweDEwMCA9PSAyNTYpXG4gICAgICAgICAgICB4IF49IDB4MTFEO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE9wdGltaXphdGlvbjogZG91YmxlIHRoZSBzaXplIG9mIHRoZSBhbnRpLWxvZyB0YWJsZSBzbyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbW9kIDI1NSB0b1xuICAgIC8vIHN0YXkgaW5zaWRlIHRoZSBib3VuZHMgKGJlY2F1c2Ugd2Ugd2lsbCBtYWlubHkgdXNlIHRoaXMgdGFibGUgZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBvZlxuICAgIC8vIHR3byBHRiBudW1iZXJzLCBubyBtb3JlKS5cbiAgICAvLyBAc2VlIHtAbGluayBtdWx9XG4gICAgZm9yIChpID0gMjU1OyBpIDwgNTEyOyBpKyspIHtcbiAgICAgICAgRVhQX1RBQkxFW2ldID0gRVhQX1RBQkxFW2kgLSAyNTVdO1xuICAgIH1cbn0oKSk7XG4vKipcbiAqIFJldHVybnMgbG9nIHZhbHVlIG9mIG4gaW5zaWRlIEdhbG9pcyBGaWVsZFxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgbG9nID0gZnVuY3Rpb24gbG9nKG4pIHtcbiAgICBpZiAobiA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9nKCcgKyBuICsgJyknKTtcbiAgICByZXR1cm4gTE9HX1RBQkxFW25dO1xufTtcbi8qKlxuICogUmV0dXJucyBhbnRpLWxvZyB2YWx1ZSBvZiBuIGluc2lkZSBHYWxvaXMgRmllbGRcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGV4cCA9IGZ1bmN0aW9uIGV4cChuKSB7XG4gICAgcmV0dXJuIEVYUF9UQUJMRVtuXTtcbn07XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG51bWJlciBpbnNpZGUgR2Fsb2lzIEZpZWxkXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIG11bCA9IGZ1bmN0aW9uIG11bCh4LCB5KSB7XG4gICAgaWYgKHggPT09IDAgfHwgeSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgLy8gc2hvdWxkIGJlIEVYUF9UQUJMRVsoTE9HX1RBQkxFW3hdICsgTE9HX1RBQkxFW3ldKSAlIDI1NV0gaWYgRVhQX1RBQkxFIHdhc24ndCBvdmVyc2l6ZWRcbiAgICAvLyBAc2VlIHtAbGluayBpbml0VGFibGVzfVxuICAgIHJldHVybiBFWFBfVEFCTEVbTE9HX1RBQkxFW3hdICsgTE9HX1RBQkxFW3ldXTtcbn07XG52YXIgZ2Fsb2lzRmllbGQgPSB7XG4gICAgbG9nOiBsb2csXG4gICAgZXhwOiBleHAsXG4gICAgbXVsOiBtdWxcbn07XG52YXIgcG9seW5vbWlhbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byBwb2x5bm9taWFscyBpbnNpZGUgR2Fsb2lzIEZpZWxkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtCdWZmZXJ9IHAxIFBvbHlub21pYWxcbiAgICAgKiBAcGFyYW0gIHtCdWZmZXJ9IHAyIFBvbHlub21pYWxcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9ICAgIFByb2R1Y3Qgb2YgcDEgYW5kIHAyXG4gICAgICovXG4gICAgZXhwb3J0cy5tdWwgPSBmdW5jdGlvbiBtdWwocDEsIHAyKSB7XG4gICAgICAgIHZhciBjb2VmZiA9IHR5cGVkYXJyYXlCdWZmZXIuYWxsb2MocDEubGVuZ3RoICsgcDIubGVuZ3RoIC0gMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcDIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb2VmZltpICsgal0gXj0gZ2Fsb2lzRmllbGQubXVsKHAxW2ldLCBwMltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZWZmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZW1haW5kZXIgb2YgcG9seW5vbWlhbHMgZGl2aXNpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0J1ZmZlcn0gZGl2aWRlbnQgUG9seW5vbWlhbFxuICAgICAqIEBwYXJhbSAge0J1ZmZlcn0gZGl2aXNvciAgUG9seW5vbWlhbFxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gICAgICAgICAgUmVtYWluZGVyXG4gICAgICovXG4gICAgZXhwb3J0cy5tb2QgPSBmdW5jdGlvbiBtb2QoZGl2aWRlbnQsIGRpdmlzb3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHR5cGVkYXJyYXlCdWZmZXIuZnJvbShkaXZpZGVudCk7XG4gICAgICAgIHdoaWxlICgocmVzdWx0Lmxlbmd0aCAtIGRpdmlzb3IubGVuZ3RoKSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgY29lZmYgPSByZXN1bHRbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdmlzb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gXj0gZ2Fsb2lzRmllbGQubXVsKGRpdmlzb3JbaV0sIGNvZWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgemVyb3MgZnJvbSBidWZmZXIgaGVhZFxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbb2Zmc2V0XSA9PT0gMClcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBpcnJlZHVjaWJsZSBnZW5lcmF0b3IgcG9seW5vbWlhbCBvZiBzcGVjaWZpZWQgZGVncmVlXG4gICAgICogKHVzZWQgYnkgUmVlZC1Tb2xvbW9uIGVuY29kZXIpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZSBEZWdyZWUgb2YgdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsXG4gICAgICogQHJldHVybiB7QnVmZmVyfSAgICAgICAgQnVmZmVyIGNvbnRhaW5pbmcgcG9seW5vbWlhbCBjb2VmZmljaWVudHNcbiAgICAgKi9cbiAgICBleHBvcnRzLmdlbmVyYXRlRUNQb2x5bm9taWFsID0gZnVuY3Rpb24gZ2VuZXJhdGVFQ1BvbHlub21pYWwoZGVncmVlKSB7XG4gICAgICAgIHZhciBwb2x5ID0gdHlwZWRhcnJheUJ1ZmZlci5mcm9tKFsxXSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHkgPSBleHBvcnRzLm11bChwb2x5LCBbMSwgZ2Fsb2lzRmllbGQuZXhwKGkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvbHk7XG4gICAgfTtcbn0pO1xudmFyIEJ1ZmZlciQxID0gYnVmZmVyLkJ1ZmZlcjtcbmZ1bmN0aW9uIFJlZWRTb2xvbW9uRW5jb2RlcihkZWdyZWUpIHtcbiAgICB0aGlzLmdlblBvbHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZWdyZWUgPSBkZWdyZWU7XG4gICAgaWYgKHRoaXMuZGVncmVlKVxuICAgICAgICB0aGlzLmluaXRpYWxpemUodGhpcy5kZWdyZWUpO1xufVxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBlbmNvZGVyLlxuICogVGhlIGlucHV0IHBhcmFtIHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBkZWdyZWVcbiAqL1xuUmVlZFNvbG9tb25FbmNvZGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZShkZWdyZWUpIHtcbiAgICAvLyBjcmVhdGUgYW4gaXJyZWR1Y2libGUgZ2VuZXJhdG9yIHBvbHlub21pYWxcbiAgICB0aGlzLmRlZ3JlZSA9IGRlZ3JlZTtcbiAgICB0aGlzLmdlblBvbHkgPSBwb2x5bm9taWFsLmdlbmVyYXRlRUNQb2x5bm9taWFsKHRoaXMuZGVncmVlKTtcbn07XG4vKipcbiAqIEVuY29kZXMgYSBjaHVuayBvZiBkYXRhXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhIEJ1ZmZlciBjb250YWluaW5nIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn0gICAgICBCdWZmZXIgY29udGFpbmluZyBlbmNvZGVkIGRhdGFcbiAqL1xuUmVlZFNvbG9tb25FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGlmICghdGhpcy5nZW5Qb2x5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RlciBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIEVDIGZvciB0aGlzIGRhdGEgYmxvY2tcbiAgICAvLyBleHRlbmRzIGRhdGEgc2l6ZSB0byBkYXRhK2dlblBvbHkgc2l6ZVxuICAgIHZhciBwYWQgPSB0eXBlZGFycmF5QnVmZmVyLmFsbG9jKHRoaXMuZGVncmVlKTtcbiAgICB2YXIgcGFkZGVkRGF0YSA9IEJ1ZmZlciQxLmNvbmNhdChbZGF0YSwgcGFkXSwgZGF0YS5sZW5ndGggKyB0aGlzLmRlZ3JlZSk7XG4gICAgLy8gVGhlIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIGFyZSB0aGUgcmVtYWluZGVyIGFmdGVyIGRpdmlkaW5nIHRoZSBkYXRhIGNvZGV3b3Jkc1xuICAgIC8vIGJ5IGEgZ2VuZXJhdG9yIHBvbHlub21pYWxcbiAgICB2YXIgcmVtYWluZGVyID0gcG9seW5vbWlhbC5tb2QocGFkZGVkRGF0YSwgdGhpcy5nZW5Qb2x5KTtcbiAgICAvLyByZXR1cm4gRUMgZGF0YSBibG9ja3MgKGxhc3QgbiBieXRlLCB3aGVyZSBuIGlzIHRoZSBkZWdyZWUgb2YgZ2VuUG9seSlcbiAgICAvLyBJZiBjb2VmZmljaWVudHMgbnVtYmVyIGluIHJlbWFpbmRlciBhcmUgbGVzcyB0aGFuIGdlblBvbHkgZGVncmVlLFxuICAgIC8vIHBhZCB3aXRoIDBzIHRvIHRoZSBsZWZ0IHRvIHJlYWNoIHRoZSBuZWVkZWQgbnVtYmVyIG9mIGNvZWZmaWNpZW50c1xuICAgIHZhciBzdGFydCA9IHRoaXMuZGVncmVlIC0gcmVtYWluZGVyLmxlbmd0aDtcbiAgICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgICAgIHZhciBidWZmID0gdHlwZWRhcnJheUJ1ZmZlci5hbGxvYyh0aGlzLmRlZ3JlZSk7XG4gICAgICAgIHJlbWFpbmRlci5jb3B5KGJ1ZmYsIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuICAgIHJldHVybiByZW1haW5kZXI7XG59O1xudmFyIHJlZWRTb2xvbW9uRW5jb2RlciA9IFJlZWRTb2xvbW9uRW5jb2Rlcjtcbi8qKlxuICogQ2hlY2sgaWYgUVIgQ29kZSB2ZXJzaW9uIGlzIHZhbGlkXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgdHJ1ZSBpZiB2YWxpZCB2ZXJzaW9uLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xudmFyIGlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkKHZlcnNpb24pIHtcbiAgICByZXR1cm4gIWlzTmFOKHZlcnNpb24pICYmIHZlcnNpb24gPj0gMSAmJiB2ZXJzaW9uIDw9IDQwO1xufTtcbnZhciB2ZXJzaW9uQ2hlY2sgPSB7XG4gICAgaXNWYWxpZDogaXNWYWxpZFxufTtcbnZhciBudW1lcmljID0gJ1swLTldKyc7XG52YXIgYWxwaGFudW1lcmljID0gJ1tBLVogJCUqK1xcXFwtLi86XSsnO1xudmFyIGthbmppID0gJyg/Olt1MzAwMC11MzAzRl18W3UzMDQwLXUzMDlGXXxbdTMwQTAtdTMwRkZdfCcgK1xuICAgICdbdUZGMDAtdUZGRUZdfFt1NEUwMC11OUZBRl18W3UyNjA1LXUyNjA2XXxbdTIxOTAtdTIxOTVdfHUyMDNCfCcgK1xuICAgICdbdTIwMTB1MjAxNXUyMDE4dTIwMTl1MjAyNXUyMDI2dTIwMUN1MjAxRHUyMjI1dTIyNjBdfCcgK1xuICAgICdbdTAzOTEtdTA0NTFdfFt1MDBBN3UwMEE4dTAwQjF1MDBCNHUwMEQ3dTAwRjddKSsnO1xua2FuamkgPSBrYW5qaS5yZXBsYWNlKC91L2csICdcXFxcdScpO1xudmFyIGJ5dGUgPSAnKD86KD8hW0EtWjAtOSAkJSorXFxcXC0uLzpdfCcgKyBrYW5qaSArICcpKD86LnxbXFxyXFxuXSkpKyc7XG52YXIgS0FOSkkgPSBuZXcgUmVnRXhwKGthbmppLCAnZycpO1xudmFyIEJZVEVfS0FOSkkgPSBuZXcgUmVnRXhwKCdbXkEtWjAtOSAkJSorXFxcXC0uLzpdKycsICdnJyk7XG52YXIgQllURSA9IG5ldyBSZWdFeHAoYnl0ZSwgJ2cnKTtcbnZhciBOVU1FUklDID0gbmV3IFJlZ0V4cChudW1lcmljLCAnZycpO1xudmFyIEFMUEhBTlVNRVJJQyA9IG5ldyBSZWdFeHAoYWxwaGFudW1lcmljLCAnZycpO1xudmFyIFRFU1RfS0FOSkkgPSBuZXcgUmVnRXhwKCdeJyArIGthbmppICsgJyQnKTtcbnZhciBURVNUX05VTUVSSUMgPSBuZXcgUmVnRXhwKCdeJyArIG51bWVyaWMgKyAnJCcpO1xudmFyIFRFU1RfQUxQSEFOVU1FUklDID0gbmV3IFJlZ0V4cCgnXltBLVowLTkgJCUqK1xcXFwtLi86XSskJyk7XG52YXIgdGVzdEthbmppID0gZnVuY3Rpb24gdGVzdEthbmppKHN0cikge1xuICAgIHJldHVybiBURVNUX0tBTkpJLnRlc3Qoc3RyKTtcbn07XG52YXIgdGVzdE51bWVyaWMgPSBmdW5jdGlvbiB0ZXN0TnVtZXJpYyhzdHIpIHtcbiAgICByZXR1cm4gVEVTVF9OVU1FUklDLnRlc3Qoc3RyKTtcbn07XG52YXIgdGVzdEFscGhhbnVtZXJpYyA9IGZ1bmN0aW9uIHRlc3RBbHBoYW51bWVyaWMoc3RyKSB7XG4gICAgcmV0dXJuIFRFU1RfQUxQSEFOVU1FUklDLnRlc3Qoc3RyKTtcbn07XG52YXIgcmVnZXggPSB7XG4gICAgS0FOSkk6IEtBTkpJLFxuICAgIEJZVEVfS0FOSkk6IEJZVEVfS0FOSkksXG4gICAgQllURTogQllURSxcbiAgICBOVU1FUklDOiBOVU1FUklDLFxuICAgIEFMUEhBTlVNRVJJQzogQUxQSEFOVU1FUklDLFxuICAgIHRlc3RLYW5qaTogdGVzdEthbmppLFxuICAgIHRlc3ROdW1lcmljOiB0ZXN0TnVtZXJpYyxcbiAgICB0ZXN0QWxwaGFudW1lcmljOiB0ZXN0QWxwaGFudW1lcmljXG59O1xudmFyIG1vZGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogTnVtZXJpYyBtb2RlIGVuY29kZXMgZGF0YSBmcm9tIHRoZSBkZWNpbWFsIGRpZ2l0IHNldCAoMCAtIDkpXG4gICAgICogKGJ5dGUgdmFsdWVzIDMwSEVYIHRvIDM5SEVYKS5cbiAgICAgKiBOb3JtYWxseSwgMyBkYXRhIGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IDEwIGJpdHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGV4cG9ydHMuTlVNRVJJQyA9IHtcbiAgICAgICAgaWQ6ICdOdW1lcmljJyxcbiAgICAgICAgYml0OiAxIDw8IDAsXG4gICAgICAgIGNjQml0czogWzEwLCAxMiwgMTRdXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbHBoYW51bWVyaWMgbW9kZSBlbmNvZGVzIGRhdGEgZnJvbSBhIHNldCBvZiA0NSBjaGFyYWN0ZXJzLFxuICAgICAqIGkuZS4gMTAgbnVtZXJpYyBkaWdpdHMgKDAgLSA5KSxcbiAgICAgKiAgICAgIDI2IGFscGhhYmV0aWMgY2hhcmFjdGVycyAoQSAtIFopLFxuICAgICAqICAgYW5kIDkgc3ltYm9scyAoU1AsICQsICUsICosICssIC0sIC4sIC8sIDopLlxuICAgICAqIE5vcm1hbGx5LCB0d28gaW5wdXQgY2hhcmFjdGVycyBhcmUgcmVwcmVzZW50ZWQgYnkgMTEgYml0cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZXhwb3J0cy5BTFBIQU5VTUVSSUMgPSB7XG4gICAgICAgIGlkOiAnQWxwaGFudW1lcmljJyxcbiAgICAgICAgYml0OiAxIDw8IDEsXG4gICAgICAgIGNjQml0czogWzksIDExLCAxM11cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluIGJ5dGUgbW9kZSwgZGF0YSBpcyBlbmNvZGVkIGF0IDggYml0cyBwZXIgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBleHBvcnRzLkJZVEUgPSB7XG4gICAgICAgIGlkOiAnQnl0ZScsXG4gICAgICAgIGJpdDogMSA8PCAyLFxuICAgICAgICBjY0JpdHM6IFs4LCAxNiwgMTZdXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgS2FuamkgbW9kZSBlZmZpY2llbnRseSBlbmNvZGVzIEthbmppIGNoYXJhY3RlcnMgaW4gYWNjb3JkYW5jZSB3aXRoXG4gICAgICogdGhlIFNoaWZ0IEpJUyBzeXN0ZW0gYmFzZWQgb24gSklTIFggMDIwOC5cbiAgICAgKiBUaGUgU2hpZnQgSklTIHZhbHVlcyBhcmUgc2hpZnRlZCBmcm9tIHRoZSBKSVMgWCAwMjA4IHZhbHVlcy5cbiAgICAgKiBKSVMgWCAwMjA4IGdpdmVzIGRldGFpbHMgb2YgdGhlIHNoaWZ0IGNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEVhY2ggdHdvLWJ5dGUgY2hhcmFjdGVyIHZhbHVlIGlzIGNvbXBhY3RlZCB0byBhIDEzLWJpdCBiaW5hcnkgY29kZXdvcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGV4cG9ydHMuS0FOSkkgPSB7XG4gICAgICAgIGlkOiAnS2FuamknLFxuICAgICAgICBiaXQ6IDEgPDwgMyxcbiAgICAgICAgY2NCaXRzOiBbOCwgMTAsIDEyXVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWl4ZWQgbW9kZSB3aWxsIGNvbnRhaW4gYSBzZXF1ZW5jZXMgb2YgZGF0YSBpbiBhIGNvbWJpbmF0aW9uIG9mIGFueSBvZlxuICAgICAqIHRoZSBtb2RlcyBkZXNjcmliZWQgYWJvdmVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgZXhwb3J0cy5NSVhFRCA9IHtcbiAgICAgICAgYml0OiAtMVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHN0b3JlIHRoZSBkYXRhIGxlbmd0aFxuICAgICAqIGFjY29yZGluZyB0byBRUiBDb2RlIHNwZWNpZmljYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TW9kZX0gICBtb2RlICAgIERhdGEgbW9kZVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgTnVtYmVyIG9mIGJpdHNcbiAgICAgKi9cbiAgICBleHBvcnRzLmdldENoYXJDb3VudEluZGljYXRvciA9IGZ1bmN0aW9uIGdldENoYXJDb3VudEluZGljYXRvcihtb2RlLCB2ZXJzaW9uKSB7XG4gICAgICAgIGlmICghbW9kZS5jY0JpdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZTogJyArIG1vZGUpO1xuICAgICAgICBpZiAoIXZlcnNpb25DaGVjay5pc1ZhbGlkKHZlcnNpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID49IDEgJiYgdmVyc2lvbiA8IDEwKVxuICAgICAgICAgICAgcmV0dXJuIG1vZGUuY2NCaXRzWzBdO1xuICAgICAgICBlbHNlIGlmICh2ZXJzaW9uIDwgMjcpXG4gICAgICAgICAgICByZXR1cm4gbW9kZS5jY0JpdHNbMV07XG4gICAgICAgIHJldHVybiBtb2RlLmNjQml0c1syXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vc3QgZWZmaWNpZW50IG1vZGUgdG8gc3RvcmUgdGhlIHNwZWNpZmllZCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFTdHIgSW5wdXQgZGF0YSBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtNb2RlfSAgICAgICAgICAgQmVzdCBtb2RlXG4gICAgICovXG4gICAgZXhwb3J0cy5nZXRCZXN0TW9kZUZvckRhdGEgPSBmdW5jdGlvbiBnZXRCZXN0TW9kZUZvckRhdGEoZGF0YVN0cikge1xuICAgICAgICBpZiAocmVnZXgudGVzdE51bWVyaWMoZGF0YVN0cikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OVU1FUklDO1xuICAgICAgICBlbHNlIGlmIChyZWdleC50ZXN0QWxwaGFudW1lcmljKGRhdGFTdHIpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQUxQSEFOVU1FUklDO1xuICAgICAgICBlbHNlIGlmIChyZWdleC50ZXN0S2FuamkoZGF0YVN0cikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5LQU5KSTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQllURTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBtb2RlIG5hbWUgYXMgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vZGV9IG1vZGUgTW9kZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAgTW9kZSBuYW1lXG4gICAgICovXG4gICAgZXhwb3J0cy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgJiYgbW9kZS5pZClcbiAgICAgICAgICAgIHJldHVybiBtb2RlLmlkO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaW5wdXQgcGFyYW0gaXMgYSB2YWxpZCBtb2RlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtICAge01vZGV9ICAgIG1vZGUgTW9kZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBtb2RlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBleHBvcnRzLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGUgJiYgbW9kZS5iaXQgJiYgbW9kZS5jY0JpdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgbW9kZSBvYmplY3QgZnJvbSBpdHMgbmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtICAge1N0cmluZ30gc3RyaW5nIE1vZGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHtNb2RlfSAgICAgICAgICBNb2RlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbSBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGNTdHIgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoIChsY1N0cikge1xuICAgICAgICAgICAgY2FzZSAnbnVtZXJpYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTlVNRVJJQztcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhbnVtZXJpYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQUxQSEFOVU1FUklDO1xuICAgICAgICAgICAgY2FzZSAna2FuamknOlxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLktBTkpJO1xuICAgICAgICAgICAgY2FzZSAnYnl0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQllURTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGU6ICcgKyBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kZSBmcm9tIGEgdmFsdWUuXG4gICAgICogSWYgdmFsdWUgaXMgbm90IGEgdmFsaWQgbW9kZSwgcmV0dXJucyBkZWZhdWx0VmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge01vZGV8U3RyaW5nfSB2YWx1ZSAgICAgICAgRW5jb2RpbmcgbW9kZVxuICAgICAqIEBwYXJhbSAge01vZGV9ICAgICAgICBkZWZhdWx0VmFsdWUgRmFsbGJhY2sgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtNb2RlfSAgICAgICAgICAgICAgICAgICAgIEVuY29kaW5nIG1vZGVcbiAgICAgKi9cbiAgICBleHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xudmFyIHZlcnNpb24gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLy8gR2VuZXJhdG9yIHBvbHlub21pYWwgdXNlZCB0byBlbmNvZGUgdmVyc2lvbiBpbmZvcm1hdGlvblxuICAgIHZhciBHMTggPSAoMSA8PCAxMikgfCAoMSA8PCAxMSkgfCAoMSA8PCAxMCkgfCAoMSA8PCA5KSB8ICgxIDw8IDgpIHwgKDEgPDwgNSkgfCAoMSA8PCAyKSB8ICgxIDw8IDApO1xuICAgIHZhciBHMThfQkNIID0gdXRpbHMuZ2V0QkNIRGlnaXQoRzE4KTtcbiAgICBmdW5jdGlvbiBnZXRCZXN0VmVyc2lvbkZvckRhdGFMZW5ndGgobW9kZSwgbGVuZ3RoLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICBmb3IgKHZhciBjdXJyZW50VmVyc2lvbiA9IDE7IGN1cnJlbnRWZXJzaW9uIDw9IDQwOyBjdXJyZW50VmVyc2lvbisrKSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IGV4cG9ydHMuZ2V0Q2FwYWNpdHkoY3VycmVudFZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXNlcnZlZEJpdHNDb3VudChtb2RlJDEsIHZlcnNpb24pIHtcbiAgICAgICAgLy8gQ2hhcmFjdGVyIGNvdW50IGluZGljYXRvciArIG1vZGUgaW5kaWNhdG9yIGJpdHNcbiAgICAgICAgcmV0dXJuIG1vZGUuZ2V0Q2hhckNvdW50SW5kaWNhdG9yKG1vZGUkMSwgdmVyc2lvbikgKyA0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUb3RhbEJpdHNGcm9tRGF0YUFycmF5KHNlZ21lbnRzLCB2ZXJzaW9uKSB7XG4gICAgICAgIHZhciB0b3RhbEJpdHMgPSAwO1xuICAgICAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVzZXJ2ZWRCaXRzID0gZ2V0UmVzZXJ2ZWRCaXRzQ291bnQoZGF0YS5tb2RlLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIHRvdGFsQml0cyArPSByZXNlcnZlZEJpdHMgKyBkYXRhLmdldEJpdHNMZW5ndGgoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b3RhbEJpdHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJlc3RWZXJzaW9uRm9yTWl4ZWREYXRhKHNlZ21lbnRzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICBmb3IgKHZhciBjdXJyZW50VmVyc2lvbiA9IDE7IGN1cnJlbnRWZXJzaW9uIDw9IDQwOyBjdXJyZW50VmVyc2lvbisrKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZ2V0VG90YWxCaXRzRnJvbURhdGFBcnJheShzZWdtZW50cywgY3VycmVudFZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSBleHBvcnRzLmdldENhcGFjaXR5KGN1cnJlbnRWZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgbW9kZS5NSVhFRCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2ZXJzaW9uIG51bWJlciBmcm9tIGEgdmFsdWUuXG4gICAgICogSWYgdmFsdWUgaXMgbm90IGEgdmFsaWQgdmVyc2lvbiwgcmV0dXJucyBkZWZhdWx0VmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICBkZWZhdWx0VmFsdWUgRmFsbGJhY2sgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uIG51bWJlclxuICAgICAqL1xuICAgIGV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodmVyc2lvbkNoZWNrLmlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3cgbXVjaCBkYXRhIGNhbiBiZSBzdG9yZWQgd2l0aCB0aGUgc3BlY2lmaWVkIFFSIGNvZGUgdmVyc2lvblxuICAgICAqIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvbiAoMS00MClcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgKiBAcGFyYW0gIHtNb2RlfSAgIG1vZGUgICAgICAgICAgICAgICAgIERhdGEgbW9kZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgUXVhbnRpdHkgb2Ygc3RvcmFibGUgZGF0YVxuICAgICAqL1xuICAgIGV4cG9ydHMuZ2V0Q2FwYWNpdHkgPSBmdW5jdGlvbiBnZXRDYXBhY2l0eSh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgbW9kZSQxKSB7XG4gICAgICAgIGlmICghdmVyc2lvbkNoZWNrLmlzVmFsaWQodmVyc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBRUiBDb2RlIHZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgQnl0ZSBtb2RlIGFzIGRlZmF1bHRcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlJDEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgbW9kZSQxID0gbW9kZS5CWVRFO1xuICAgICAgICAvLyBUb3RhbCBjb2Rld29yZHMgZm9yIHRoaXMgUVIgY29kZSB2ZXJzaW9uIChEYXRhICsgRXJyb3IgY29ycmVjdGlvbilcbiAgICAgICAgdmFyIHRvdGFsQ29kZXdvcmRzID0gdXRpbHMuZ2V0U3ltYm9sVG90YWxDb2Rld29yZHModmVyc2lvbik7XG4gICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICB2YXIgZWNUb3RhbENvZGV3b3JkcyA9IGVycm9yQ29ycmVjdGlvbkNvZGUuZ2V0VG90YWxDb2Rld29yZHNDb3VudCh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG4gICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgICAgICB2YXIgZGF0YVRvdGFsQ29kZXdvcmRzQml0cyA9ICh0b3RhbENvZGV3b3JkcyAtIGVjVG90YWxDb2Rld29yZHMpICogODtcbiAgICAgICAgaWYgKG1vZGUkMSA9PT0gbW9kZS5NSVhFRClcbiAgICAgICAgICAgIHJldHVybiBkYXRhVG90YWxDb2Rld29yZHNCaXRzO1xuICAgICAgICB2YXIgdXNhYmxlQml0cyA9IGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMgLSBnZXRSZXNlcnZlZEJpdHNDb3VudChtb2RlJDEsIHZlcnNpb24pO1xuICAgICAgICAvLyBSZXR1cm4gbWF4IG51bWJlciBvZiBzdG9yYWJsZSBjb2Rld29yZHNcbiAgICAgICAgc3dpdGNoIChtb2RlJDEpIHtcbiAgICAgICAgICAgIGNhc2UgbW9kZS5OVU1FUklDOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh1c2FibGVCaXRzIC8gMTApICogMyk7XG4gICAgICAgICAgICBjYXNlIG1vZGUuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh1c2FibGVCaXRzIC8gMTEpICogMik7XG4gICAgICAgICAgICBjYXNlIG1vZGUuS0FOSkk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodXNhYmxlQml0cyAvIDEzKTtcbiAgICAgICAgICAgIGNhc2UgbW9kZS5CWVRFOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih1c2FibGVCaXRzIC8gOCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gdmVyc2lvbiBuZWVkZWQgdG8gY29udGFpbiB0aGUgYW1vdW50IG9mIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1NlZ21lbnR9IGRhdGEgICAgICAgICAgICAgICAgICAgIFNlZ21lbnQgb2YgZGF0YVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW2Vycm9yQ29ycmVjdGlvbkxldmVsPUhdIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgKiBAcGFyYW0gIHtNb2RlfSBtb2RlICAgICAgICAgICAgICAgICAgICAgICBEYXRhIG1vZGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAgICAgKi9cbiAgICBleHBvcnRzLmdldEJlc3RWZXJzaW9uRm9yRGF0YSA9IGZ1bmN0aW9uIGdldEJlc3RWZXJzaW9uRm9yRGF0YShkYXRhLCBlcnJvckNvcnJlY3Rpb25MZXZlbCQxKSB7XG4gICAgICAgIHZhciBzZWc7XG4gICAgICAgIHZhciBlY2wgPSBlcnJvckNvcnJlY3Rpb25MZXZlbC5mcm9tKGVycm9yQ29ycmVjdGlvbkxldmVsJDEsIGVycm9yQ29ycmVjdGlvbkxldmVsLk0pO1xuICAgICAgICBpZiAoaXNhcnJheShkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRCZXN0VmVyc2lvbkZvck1peGVkRGF0YShkYXRhLCBlY2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWcgPSBkYXRhWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VnID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QmVzdFZlcnNpb25Gb3JEYXRhTGVuZ3RoKHNlZy5tb2RlLCBzZWcuZ2V0TGVuZ3RoKCksIGVjbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnNpb24gaW5mb3JtYXRpb24gd2l0aCByZWxhdGl2ZSBlcnJvciBjb3JyZWN0aW9uIGJpdHNcbiAgICAgKlxuICAgICAqIFRoZSB2ZXJzaW9uIGluZm9ybWF0aW9uIGlzIGluY2x1ZGVkIGluIFFSIENvZGUgc3ltYm9scyBvZiB2ZXJzaW9uIDcgb3IgbGFyZ2VyLlxuICAgICAqIEl0IGNvbnNpc3RzIG9mIGFuIDE4LWJpdCBzZXF1ZW5jZSBjb250YWluaW5nIDYgZGF0YSBiaXRzLFxuICAgICAqIHdpdGggMTIgZXJyb3IgY29ycmVjdGlvbiBiaXRzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlICgxOCwgNikgR29sYXkgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgRW5jb2RlZCB2ZXJzaW9uIGluZm8gYml0c1xuICAgICAqL1xuICAgIGV4cG9ydHMuZ2V0RW5jb2RlZEJpdHMgPSBmdW5jdGlvbiBnZXRFbmNvZGVkQml0cyh2ZXJzaW9uKSB7XG4gICAgICAgIGlmICghdmVyc2lvbkNoZWNrLmlzVmFsaWQodmVyc2lvbikgfHwgdmVyc2lvbiA8IDcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBRUiBDb2RlIHZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZCA9IHZlcnNpb24gPDwgMTI7XG4gICAgICAgIHdoaWxlICh1dGlscy5nZXRCQ0hEaWdpdChkKSAtIEcxOF9CQ0ggPj0gMCkge1xuICAgICAgICAgICAgZCBePSAoRzE4IDw8ICh1dGlscy5nZXRCQ0hEaWdpdChkKSAtIEcxOF9CQ0gpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZlcnNpb24gPDwgMTIpIHwgZDtcbiAgICB9O1xufSk7XG52YXIgRzE1ID0gKDEgPDwgMTApIHwgKDEgPDwgOCkgfCAoMSA8PCA1KSB8ICgxIDw8IDQpIHwgKDEgPDwgMikgfCAoMSA8PCAxKSB8ICgxIDw8IDApO1xudmFyIEcxNV9NQVNLID0gKDEgPDwgMTQpIHwgKDEgPDwgMTIpIHwgKDEgPDwgMTApIHwgKDEgPDwgNCkgfCAoMSA8PCAxKTtcbnZhciBHMTVfQkNIID0gdXRpbHMuZ2V0QkNIRGlnaXQoRzE1KTtcbi8qKlxuICogUmV0dXJucyBmb3JtYXQgaW5mb3JtYXRpb24gd2l0aCByZWxhdGl2ZSBlcnJvciBjb3JyZWN0aW9uIGJpdHNcbiAqXG4gKiBUaGUgZm9ybWF0IGluZm9ybWF0aW9uIGlzIGEgMTUtYml0IHNlcXVlbmNlIGNvbnRhaW5pbmcgNSBkYXRhIGJpdHMsXG4gKiB3aXRoIDEwIGVycm9yIGNvcnJlY3Rpb24gYml0cyBjYWxjdWxhdGVkIHVzaW5nIHRoZSAoMTUsIDUpIEJDSCBjb2RlLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNrICAgICAgICAgICAgICAgICBNYXNrIHBhdHRlcm5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgRW5jb2RlZCBmb3JtYXQgaW5mb3JtYXRpb24gYml0c1xuICovXG52YXIgZ2V0RW5jb2RlZEJpdHMgPSBmdW5jdGlvbiBnZXRFbmNvZGVkQml0cyhlcnJvckNvcnJlY3Rpb25MZXZlbCwgbWFzaykge1xuICAgIHZhciBkYXRhID0gKChlcnJvckNvcnJlY3Rpb25MZXZlbC5iaXQgPDwgMykgfCBtYXNrKTtcbiAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgd2hpbGUgKHV0aWxzLmdldEJDSERpZ2l0KGQpIC0gRzE1X0JDSCA+PSAwKSB7XG4gICAgICAgIGQgXj0gKEcxNSA8PCAodXRpbHMuZ2V0QkNIRGlnaXQoZCkgLSBHMTVfQkNIKSk7XG4gICAgfVxuICAgIC8vIHhvciBmaW5hbCBkYXRhIHdpdGggbWFzayBwYXR0ZXJuIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gbm8gY29tYmluYXRpb24gb2YgRXJyb3IgQ29ycmVjdGlvbiBMZXZlbCBhbmQgZGF0YSBtYXNrIHBhdHRlcm5cbiAgICAvLyB3aWxsIHJlc3VsdCBpbiBhbiBhbGwtemVybyBkYXRhIHN0cmluZ1xuICAgIHJldHVybiAoKGRhdGEgPDwgMTApIHwgZCkgXiBHMTVfTUFTSztcbn07XG52YXIgZm9ybWF0SW5mbyA9IHtcbiAgICBnZXRFbmNvZGVkQml0czogZ2V0RW5jb2RlZEJpdHNcbn07XG5mdW5jdGlvbiBOdW1lcmljRGF0YShkYXRhKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZS5OVU1FUklDO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbn1cbk51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKGxlbmd0aCkge1xuICAgIHJldHVybiAxMCAqIE1hdGguZmxvb3IobGVuZ3RoIC8gMykgKyAoKGxlbmd0aCAlIDMpID8gKChsZW5ndGggJSAzKSAqIDMgKyAxKSA6IDApO1xufTtcbk51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG59O1xuTnVtZXJpY0RhdGEucHJvdG90eXBlLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKCkge1xuICAgIHJldHVybiBOdW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoKHRoaXMuZGF0YS5sZW5ndGgpO1xufTtcbk51bWVyaWNEYXRhLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKGJpdEJ1ZmZlcikge1xuICAgIHZhciBpLCBncm91cCwgdmFsdWU7XG4gICAgLy8gVGhlIGlucHV0IGRhdGEgc3RyaW5nIGlzIGRpdmlkZWQgaW50byBncm91cHMgb2YgdGhyZWUgZGlnaXRzLFxuICAgIC8vIGFuZCBlYWNoIGdyb3VwIGlzIGNvbnZlcnRlZCB0byBpdHMgMTAtYml0IGJpbmFyeSBlcXVpdmFsZW50LlxuICAgIGZvciAoaSA9IDA7IGkgKyAzIDw9IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBncm91cCA9IHRoaXMuZGF0YS5zdWJzdHIoaSwgMyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcbiAgICAgICAgYml0QnVmZmVyLnB1dCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIGlucHV0IGRpZ2l0cyBpcyBub3QgYW4gZXhhY3QgbXVsdGlwbGUgb2YgdGhyZWUsXG4gICAgLy8gdGhlIGZpbmFsIG9uZSBvciB0d28gZGlnaXRzIGFyZSBjb252ZXJ0ZWQgdG8gNCBvciA3IGJpdHMgcmVzcGVjdGl2ZWx5LlxuICAgIHZhciByZW1haW5pbmdOdW0gPSB0aGlzLmRhdGEubGVuZ3RoIC0gaTtcbiAgICBpZiAocmVtYWluaW5nTnVtID4gMCkge1xuICAgICAgICBncm91cCA9IHRoaXMuZGF0YS5zdWJzdHIoaSk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcbiAgICAgICAgYml0QnVmZmVyLnB1dCh2YWx1ZSwgcmVtYWluaW5nTnVtICogMyArIDEpO1xuICAgIH1cbn07XG52YXIgbnVtZXJpY0RhdGEgPSBOdW1lcmljRGF0YTtcbi8qKlxuICogQXJyYXkgb2YgY2hhcmFjdGVycyBhdmFpbGFibGUgaW4gYWxwaGFudW1lcmljIG1vZGVcbiAqXG4gKiBBcyBwZXIgUVIgQ29kZSBzcGVjaWZpY2F0aW9uLCB0byBlYWNoIGNoYXJhY3RlclxuICogaXMgYXNzaWduZWQgYSB2YWx1ZSBmcm9tIDAgdG8gNDQgd2hpY2ggaW4gdGhpcyBjYXNlIGNvaW5jaWRlc1xuICogd2l0aCB0aGUgYXJyYXkgaW5kZXhcbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciBBTFBIQV9OVU1fQ0hBUlMgPSBbXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJyxcbiAgICAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsXG4gICAgJyAnLCAnJCcsICclJywgJyonLCAnKycsICctJywgJy4nLCAnLycsICc6J1xuXTtcbmZ1bmN0aW9uIEFscGhhbnVtZXJpY0RhdGEoZGF0YSkge1xuICAgIHRoaXMubW9kZSA9IG1vZGUuQUxQSEFOVU1FUklDO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5BbHBoYW51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKGxlbmd0aCkge1xuICAgIHJldHVybiAxMSAqIE1hdGguZmxvb3IobGVuZ3RoIC8gMikgKyA2ICogKGxlbmd0aCAlIDIpO1xufTtcbkFscGhhbnVtZXJpY0RhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbn07XG5BbHBoYW51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCgpIHtcbiAgICByZXR1cm4gQWxwaGFudW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoKHRoaXMuZGF0YS5sZW5ndGgpO1xufTtcbkFscGhhbnVtZXJpY0RhdGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoYml0QnVmZmVyKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gSW5wdXQgZGF0YSBjaGFyYWN0ZXJzIGFyZSBkaXZpZGVkIGludG8gZ3JvdXBzIG9mIHR3byBjaGFyYWN0ZXJzXG4gICAgLy8gYW5kIGVuY29kZWQgYXMgMTEtYml0IGJpbmFyeSBjb2Rlcy5cbiAgICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciB2YWx1ZSBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG11bHRpcGxpZWQgYnkgNDVcbiAgICAgICAgdmFyIHZhbHVlID0gQUxQSEFfTlVNX0NIQVJTLmluZGV4T2YodGhpcy5kYXRhW2ldKSAqIDQ1O1xuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIHZhbHVlIG9mIHRoZSBzZWNvbmQgZGlnaXQgaXMgYWRkZWQgdG8gdGhlIHByb2R1Y3RcbiAgICAgICAgdmFsdWUgKz0gQUxQSEFfTlVNX0NIQVJTLmluZGV4T2YodGhpcy5kYXRhW2kgKyAxXSk7XG4gICAgICAgIC8vIFRoZSBzdW0gaXMgdGhlbiBzdG9yZWQgYXMgMTEtYml0IGJpbmFyeSBudW1iZXJcbiAgICAgICAgYml0QnVmZmVyLnB1dCh2YWx1ZSwgMTEpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIGlucHV0IGRhdGEgY2hhcmFjdGVycyBpcyBub3QgYSBtdWx0aXBsZSBvZiB0d28sXG4gICAgLy8gdGhlIGNoYXJhY3RlciB2YWx1ZSBvZiB0aGUgZmluYWwgY2hhcmFjdGVyIGlzIGVuY29kZWQgYXMgYSA2LWJpdCBiaW5hcnkgbnVtYmVyLlxuICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoICUgMikge1xuICAgICAgICBiaXRCdWZmZXIucHV0KEFMUEhBX05VTV9DSEFSUy5pbmRleE9mKHRoaXMuZGF0YVtpXSksIDYpO1xuICAgIH1cbn07XG52YXIgYWxwaGFudW1lcmljRGF0YSA9IEFscGhhbnVtZXJpY0RhdGE7XG5mdW5jdGlvbiBCeXRlRGF0YShkYXRhKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZS5CWVRFO1xuICAgIHRoaXMuZGF0YSA9IHR5cGVkYXJyYXlCdWZmZXIuZnJvbShkYXRhKTtcbn1cbkJ5dGVEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKGxlbmd0aCkge1xuICAgIHJldHVybiBsZW5ndGggKiA4O1xufTtcbkJ5dGVEYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG59O1xuQnl0ZURhdGEucHJvdG90eXBlLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKCkge1xuICAgIHJldHVybiBCeXRlRGF0YS5nZXRCaXRzTGVuZ3RoKHRoaXMuZGF0YS5sZW5ndGgpO1xufTtcbkJ5dGVEYXRhLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChiaXRCdWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYml0QnVmZmVyLnB1dCh0aGlzLmRhdGFbaV0sIDgpO1xuICAgIH1cbn07XG52YXIgYnl0ZURhdGEgPSBCeXRlRGF0YTtcbmZ1bmN0aW9uIEthbmppRGF0YShkYXRhKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZS5LQU5KSTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuS2FuamlEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKGxlbmd0aCkge1xuICAgIHJldHVybiBsZW5ndGggKiAxMztcbn07XG5LYW5qaURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbn07XG5LYW5qaURhdGEucHJvdG90eXBlLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoKCkge1xuICAgIHJldHVybiBLYW5qaURhdGEuZ2V0Qml0c0xlbmd0aCh0aGlzLmRhdGEubGVuZ3RoKTtcbn07XG5LYW5qaURhdGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJpdEJ1ZmZlcikge1xuICAgIHZhciBpO1xuICAgIC8vIEluIHRoZSBTaGlmdCBKSVMgc3lzdGVtLCBLYW5qaSBjaGFyYWN0ZXJzIGFyZSByZXByZXNlbnRlZCBieSBhIHR3byBieXRlIGNvbWJpbmF0aW9uLlxuICAgIC8vIFRoZXNlIGJ5dGUgdmFsdWVzIGFyZSBzaGlmdGVkIGZyb20gdGhlIEpJUyBYIDAyMDggdmFsdWVzLlxuICAgIC8vIEpJUyBYIDAyMDggZ2l2ZXMgZGV0YWlscyBvZiB0aGUgc2hpZnQgY29kZWQgcmVwcmVzZW50YXRpb24uXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSB1dGlscy50b1NKSVModGhpcy5kYXRhW2ldKTtcbiAgICAgICAgLy8gRm9yIGNoYXJhY3RlcnMgd2l0aCBTaGlmdCBKSVMgdmFsdWVzIGZyb20gMHg4MTQwIHRvIDB4OUZGQzpcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ODE0MCAmJiB2YWx1ZSA8PSAweDlGRkMpIHtcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IDB4ODE0MCBmcm9tIFNoaWZ0IEpJUyB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUgLT0gMHg4MTQwO1xuICAgICAgICAgICAgLy8gRm9yIGNoYXJhY3RlcnMgd2l0aCBTaGlmdCBKSVMgdmFsdWVzIGZyb20gMHhFMDQwIHRvIDB4RUJCRlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID49IDB4RTA0MCAmJiB2YWx1ZSA8PSAweEVCQkYpIHtcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IDB4QzE0MCBmcm9tIFNoaWZ0IEpJUyB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUgLT0gMHhDMTQwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNKSVMgY2hhcmFjdGVyOiAnICsgdGhpcy5kYXRhW2ldICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgeW91ciBjaGFyc2V0IGlzIFVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbHkgbW9zdCBzaWduaWZpY2FudCBieXRlIG9mIHJlc3VsdCBieSAweEMwXG4gICAgICAgIC8vIGFuZCBhZGQgbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZSB0byBwcm9kdWN0XG4gICAgICAgIHZhbHVlID0gKCgodmFsdWUgPj4+IDgpICYgMHhmZikgKiAweEMwKSArICh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgICAvLyBDb252ZXJ0IHJlc3VsdCB0byBhIDEzLWJpdCBiaW5hcnkgc3RyaW5nXG4gICAgICAgIGJpdEJ1ZmZlci5wdXQodmFsdWUsIDEzKTtcbiAgICB9XG59O1xudmFyIGthbmppRGF0YSA9IEthbmppRGF0YTtcbnZhciBkaWprc3RyYV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBDcmVhdGVkIDIwMDgtMDgtMTkuXG4gICAgICpcbiAgICAgKiBEaWprc3RyYSBwYXRoLWZpbmRpbmcgZnVuY3Rpb25zLiBBZGFwdGVkIGZyb20gdGhlIERpamtzdGFyIFB5dGhvbiBwcm9qZWN0LlxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IChDKSAyMDA4XG4gICAgICogICBXeWF0dCBCYWxkd2luIDxzZWxmQHd5YXR0YmFsZHdpbi5jb20+XG4gICAgICogICBBbGwgcmlnaHRzIHJlc2VydmVkXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICpcbiAgICAgKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICAgICAqIFRIRSBTT0ZUV0FSRS5cbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIGRpamtzdHJhID0ge1xuICAgICAgICBzaW5nbGVfc291cmNlX3Nob3J0ZXN0X3BhdGhzOiBmdW5jdGlvbiAoZ3JhcGgsIHMsIGQpIHtcbiAgICAgICAgICAgIC8vIFByZWRlY2Vzc29yIG1hcCBmb3IgZWFjaCBub2RlIHRoYXQgaGFzIGJlZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAvLyBub2RlIElEID0+IHByZWRlY2Vzc29yIG5vZGUgSURcbiAgICAgICAgICAgIHZhciBwcmVkZWNlc3NvcnMgPSB7fTtcbiAgICAgICAgICAgIC8vIENvc3RzIG9mIHNob3J0ZXN0IHBhdGhzIGZyb20gcyB0byBhbGwgbm9kZXMgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICAvLyBub2RlIElEID0+IGNvc3RcbiAgICAgICAgICAgIHZhciBjb3N0cyA9IHt9O1xuICAgICAgICAgICAgY29zdHNbc10gPSAwO1xuICAgICAgICAgICAgLy8gQ29zdHMgb2Ygc2hvcnRlc3QgcGF0aHMgZnJvbSBzIHRvIGFsbCBub2RlcyBlbmNvdW50ZXJlZDsgZGlmZmVycyBmcm9tXG4gICAgICAgICAgICAvLyBgY29zdHNgIGluIHRoYXQgaXQgcHJvdmlkZXMgZWFzeSBhY2Nlc3MgdG8gdGhlIG5vZGUgdGhhdCBjdXJyZW50bHkgaGFzXG4gICAgICAgICAgICAvLyB0aGUga25vd24gc2hvcnRlc3QgcGF0aCBmcm9tIHMuXG4gICAgICAgICAgICAvLyBYWFg6IERvIHdlIGFjdHVhbGx5IG5lZWQgYm90aCBgY29zdHNgIGFuZCBgb3BlbmA/XG4gICAgICAgICAgICB2YXIgb3BlbiA9IGRpamtzdHJhLlByaW9yaXR5UXVldWUubWFrZSgpO1xuICAgICAgICAgICAgb3Blbi5wdXNoKHMsIDApO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3QsIHUsIHYsIGNvc3Rfb2Zfc190b191LCBhZGphY2VudF9ub2RlcywgY29zdF9vZl9lLCBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSwgY29zdF9vZl9zX3RvX3YsIGZpcnN0X3Zpc2l0O1xuICAgICAgICAgICAgd2hpbGUgKCFvcGVuLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgbm9kZXMgcmVtYWluaW5nIGluIGdyYXBoIHRoYXQgaGF2ZSBhIGtub3duIGNvc3QgZnJvbSBzLFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIG5vZGUsIHUsIHRoYXQgY3VycmVudGx5IGhhcyB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHMuXG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IG9wZW4ucG9wKCk7XG4gICAgICAgICAgICAgICAgdSA9IGNsb3Nlc3QudmFsdWU7XG4gICAgICAgICAgICAgICAgY29zdF9vZl9zX3RvX3UgPSBjbG9zZXN0LmNvc3Q7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5vZGVzIGFkamFjZW50IHRvIHUuLi5cbiAgICAgICAgICAgICAgICBhZGphY2VudF9ub2RlcyA9IGdyYXBoW3VdIHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCBleHBsb3JlIHRoZSBlZGdlcyB0aGF0IGNvbm5lY3QgdSB0byB0aG9zZSBub2RlcywgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29zdCBvZiB0aGUgc2hvcnRlc3QgcGF0aHMgdG8gYW55IG9yIGFsbCBvZiB0aG9zZSBub2RlcyBhc1xuICAgICAgICAgICAgICAgIC8vIG5lY2Vzc2FyeS4gdiBpcyB0aGUgbm9kZSBhY3Jvc3MgdGhlIGN1cnJlbnQgZWRnZSBmcm9tIHUuXG4gICAgICAgICAgICAgICAgZm9yICh2IGluIGFkamFjZW50X25vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudF9ub2Rlcy5oYXNPd25Qcm9wZXJ0eSh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb3N0IG9mIHRoZSBlZGdlIHJ1bm5pbmcgZnJvbSB1IHRvIHYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3N0X29mX2UgPSBhZGphY2VudF9ub2Rlc1t2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgcyB0byB1IHBsdXMgdGhlIGNvc3Qgb2YgdSB0byB2IGFjcm9zcyBlLS10aGlzIGlzICphKlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29zdCBmcm9tIHMgdG8gdiB0aGF0IG1heSBvciBtYXkgbm90IGJlIGxlc3MgdGhhbiB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga25vd24gY29zdCB0byB2LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29zdF9vZl9zX3RvX3VfcGx1c19jb3N0X29mX2UgPSBjb3N0X29mX3NfdG9fdSArIGNvc3Rfb2ZfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgdmlzaXRlZCB2IHlldCBPUiBpZiB0aGUgY3VycmVudCBrbm93biBjb3N0IGZyb20gcyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdiBpcyBncmVhdGVyIHRoYW4gdGhlIG5ldyBjb3N0IHdlIGp1c3QgZm91bmQgKGNvc3Qgb2YgcyB0byB1IHBsdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvc3Qgb2YgdSB0byB2IGFjcm9zcyBlKSwgdXBkYXRlIHYncyBjb3N0IGluIHRoZSBjb3N0IGxpc3QgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdidzIHByZWRlY2Vzc29yIGluIHRoZSBwcmVkZWNlc3NvciBsaXN0IChpdCdzIG5vdyB1KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvc3Rfb2Zfc190b192ID0gY29zdHNbdl07XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF92aXNpdCA9ICh0eXBlb2YgY29zdHNbdl0gPT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdF92aXNpdCB8fCBjb3N0X29mX3NfdG9fdiA+IGNvc3Rfb2Zfc190b191X3BsdXNfY29zdF9vZl9lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29zdHNbdl0gPSBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuLnB1c2godiwgY29zdF9vZl9zX3RvX3VfcGx1c19jb3N0X29mX2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRlY2Vzc29yc1t2XSA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb3N0c1tkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gWydDb3VsZCBub3QgZmluZCBhIHBhdGggZnJvbSAnLCBzLCAnIHRvICcsIGQsICcuJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3JzO1xuICAgICAgICB9LFxuICAgICAgICBleHRyYWN0X3Nob3J0ZXN0X3BhdGhfZnJvbV9wcmVkZWNlc3Nvcl9saXN0OiBmdW5jdGlvbiAocHJlZGVjZXNzb3JzLCBkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciB1ID0gZDtcbiAgICAgICAgICAgIHdoaWxlICh1KSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaCh1KTtcbiAgICAgICAgICAgICAgICB1ID0gcHJlZGVjZXNzb3JzW3VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kX3BhdGg6IGZ1bmN0aW9uIChncmFwaCwgcywgZCkge1xuICAgICAgICAgICAgdmFyIHByZWRlY2Vzc29ycyA9IGRpamtzdHJhLnNpbmdsZV9zb3VyY2Vfc2hvcnRlc3RfcGF0aHMoZ3JhcGgsIHMsIGQpO1xuICAgICAgICAgICAgcmV0dXJuIGRpamtzdHJhLmV4dHJhY3Rfc2hvcnRlc3RfcGF0aF9mcm9tX3ByZWRlY2Vzc29yX2xpc3QocHJlZGVjZXNzb3JzLCBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdmVyeSBuYWl2ZSBwcmlvcml0eSBxdWV1ZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIFByaW9yaXR5UXVldWU6IHtcbiAgICAgICAgICAgIG1ha2U6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSBkaWprc3RyYS5Qcmlvcml0eVF1ZXVlLCB0ID0ge30sIGtleTtcbiAgICAgICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBUKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChULmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRba2V5XSA9IFRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0LnF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdC5zb3J0ZXIgPSBvcHRzLnNvcnRlciB8fCBULmRlZmF1bHRfc29ydGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRfc29ydGVyOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmNvc3QgLSBiLmNvc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYSBuZXcgaXRlbSB0byB0aGUgcXVldWUgYW5kIGVuc3VyZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBlbGVtZW50XG4gICAgICAgICAgICAgKiBpcyBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAodmFsdWUsIGNvc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHsgdmFsdWU6IHZhbHVlLCBjb3N0OiBjb3N0IH07XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuc29ydCh0aGlzLnNvcnRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZWxlbWVudCBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIG5vZGUuanMgbW9kdWxlIGV4cG9ydHNcbiAgICB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmE7XG4gICAgfVxufSk7XG52YXIgc2VnbWVudHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBVVEY4IGJ5dGUgbGVuZ3RoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciBJbnB1dCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBOdW1iZXIgb2YgYnl0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0cmluZ0J5dGVMZW5ndGgoc3RyKSB7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHNlZ21lbnRzIG9mIHRoZSBzcGVjaWZpZWQgbW9kZVxuICAgICAqIGZyb20gYSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge01vZGV9ICAgbW9kZSBTZWdtZW50IG1vZGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciAgU3RyaW5nIHRvIHByb2Nlc3NcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQXJyYXkgb2Ygb2JqZWN0IHdpdGggc2VnbWVudHMgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNlZ21lbnRzKHJlZ2V4LCBtb2RlLCBzdHIpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnZXguZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0WzBdLFxuICAgICAgICAgICAgICAgIGluZGV4OiByZXN1bHQuaW5kZXgsXG4gICAgICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHJlc3VsdFswXS5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgYSBzZXJpZXMgb2Ygc2VnbWVudHMgd2l0aCB0aGUgYXBwcm9wcmlhdGVcbiAgICAgKiBtb2RlcyBmcm9tIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFTdHIgSW5wdXQgc3RyaW5nXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTZWdtZW50c0Zyb21TdHJpbmcoZGF0YVN0cikge1xuICAgICAgICB2YXIgbnVtU2VncyA9IGdldFNlZ21lbnRzKHJlZ2V4Lk5VTUVSSUMsIG1vZGUuTlVNRVJJQywgZGF0YVN0cik7XG4gICAgICAgIHZhciBhbHBoYU51bVNlZ3MgPSBnZXRTZWdtZW50cyhyZWdleC5BTFBIQU5VTUVSSUMsIG1vZGUuQUxQSEFOVU1FUklDLCBkYXRhU3RyKTtcbiAgICAgICAgdmFyIGJ5dGVTZWdzO1xuICAgICAgICB2YXIga2FuamlTZWdzO1xuICAgICAgICBpZiAodXRpbHMuaXNLYW5qaU1vZGVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGJ5dGVTZWdzID0gZ2V0U2VnbWVudHMocmVnZXguQllURSwgbW9kZS5CWVRFLCBkYXRhU3RyKTtcbiAgICAgICAgICAgIGthbmppU2VncyA9IGdldFNlZ21lbnRzKHJlZ2V4LktBTkpJLCBtb2RlLktBTkpJLCBkYXRhU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVTZWdzID0gZ2V0U2VnbWVudHMocmVnZXguQllURV9LQU5KSSwgbW9kZS5CWVRFLCBkYXRhU3RyKTtcbiAgICAgICAgICAgIGthbmppU2VncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWdzID0gbnVtU2Vncy5jb25jYXQoYWxwaGFOdW1TZWdzLCBieXRlU2Vncywga2FuamlTZWdzKTtcbiAgICAgICAgcmV0dXJuIHNlZ3NcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChzMSwgczIpIHtcbiAgICAgICAgICAgIHJldHVybiBzMS5pbmRleCAtIHMyLmluZGV4O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG9iai5kYXRhLFxuICAgICAgICAgICAgICAgIG1vZGU6IG9iai5tb2RlLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogb2JqLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG93IG1hbnkgYml0cyBhcmUgbmVlZGVkIHRvIGVuY29kZSBhIHN0cmluZyBvZlxuICAgICAqIHNwZWNpZmllZCBsZW5ndGggd2l0aCB0aGUgc3BlY2lmaWVkIG1vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGVuZ3RoIFN0cmluZyBsZW5ndGhcbiAgICAgKiBAcGFyYW0gIHtNb2RlfSBtb2RlICAgICBTZWdtZW50IG1vZGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICBCaXQgbGVuZ3RoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2VnbWVudEJpdHNMZW5ndGgobGVuZ3RoLCBtb2RlJDEpIHtcbiAgICAgICAgc3dpdGNoIChtb2RlJDEpIHtcbiAgICAgICAgICAgIGNhc2UgbW9kZS5OVU1FUklDOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIG1vZGUuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYW51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgbW9kZS5LQU5KSTpcbiAgICAgICAgICAgICAgICByZXR1cm4ga2FuamlEYXRhLmdldEJpdHNMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgbW9kZS5CWVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiBieXRlRGF0YS5nZXRCaXRzTGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFkamFjZW50IHNlZ21lbnRzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbW9kZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHNlZ3MgQXJyYXkgb2Ygb2JqZWN0IHdpdGggc2VnbWVudHMgZGF0YVxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZVNlZ21lbnRzKHNlZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHtcbiAgICAgICAgICAgIHZhciBwcmV2U2VnID0gYWNjLmxlbmd0aCAtIDEgPj0gMCA/IGFjY1thY2MubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKHByZXZTZWcgJiYgcHJldlNlZy5tb2RlID09PSBjdXJyLm1vZGUpIHtcbiAgICAgICAgICAgICAgICBhY2NbYWNjLmxlbmd0aCAtIDFdLmRhdGEgKz0gY3Vyci5kYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbGlzdCBvZiBhbGwgcG9zc2libGUgbm9kZXMgY29tYmluYXRpb24gd2hpY2hcbiAgICAgKiB3aWxsIGJlIHVzZWQgdG8gYnVpbGQgYSBzZWdtZW50cyBncmFwaC5cbiAgICAgKlxuICAgICAqIE5vZGVzIGFyZSBkaXZpZGVkIGJ5IGdyb3Vwcy4gRWFjaCBncm91cCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIGFsbCB0aGUgbW9kZXNcbiAgICAgKiBpbiB3aGljaCBpcyBwb3NzaWJsZSB0byBlbmNvZGUgdGhlIGdpdmVuIHRleHQuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSB0aGUgdGV4dCAnMTIzNDUnIGNhbiBiZSBlbmNvZGVkIGFzIE51bWVyaWMsIEFscGhhbnVtZXJpYyBvciBCeXRlLlxuICAgICAqIFRoZSBncm91cCBmb3IgJzEyMzQ1JyB3aWxsIGNvbnRhaW4gdGhlbiAzIG9iamVjdHMsIG9uZSBmb3IgZWFjaFxuICAgICAqIHBvc3NpYmxlIGVuY29kaW5nIG1vZGUuXG4gICAgICpcbiAgICAgKiBFYWNoIG5vZGUgcmVwcmVzZW50cyBhIHBvc3NpYmxlIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gc2VncyBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgQXJyYXkgb2Ygb2JqZWN0IHdpdGggc2VnbWVudHMgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ1aWxkTm9kZXMoc2Vncykge1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnLm1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIG1vZGUuTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChbc2VnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogbW9kZS5BTFBIQU5VTUVSSUMsIGxlbmd0aDogc2VnLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogbW9kZS5CWVRFLCBsZW5ndGg6IHNlZy5sZW5ndGggfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtb2RlLkFMUEhBTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChbc2VnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogbW9kZS5CWVRFLCBsZW5ndGg6IHNlZy5sZW5ndGggfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtb2RlLktBTkpJOlxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKFtzZWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGRhdGE6IHNlZy5kYXRhLCBtb2RlOiBtb2RlLkJZVEUsIGxlbmd0aDogZ2V0U3RyaW5nQnl0ZUxlbmd0aChzZWcuZGF0YSkgfVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBtb2RlLkJZVEU6XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogbW9kZS5CWVRFLCBsZW5ndGg6IGdldFN0cmluZ0J5dGVMZW5ndGgoc2VnLmRhdGEpIH1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBncmFwaCBmcm9tIGEgbGlzdCBvZiBub2Rlcy5cbiAgICAgKiBBbGwgc2VnbWVudHMgaW4gZWFjaCBub2RlIGdyb3VwIHdpbGwgYmUgY29ubmVjdGVkIHdpdGggYWxsIHRoZSBzZWdtZW50cyBvZlxuICAgICAqIHRoZSBuZXh0IGdyb3VwIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEF0IGVhY2ggY29ubmVjdGlvbiB3aWxsIGJlIGFzc2lnbmVkIGEgd2VpZ2h0IGRlcGVuZGluZyBvbiB0aGVcbiAgICAgKiBzZWdtZW50J3MgYnl0ZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbm9kZXMgICAgQXJyYXkgb2Ygb2JqZWN0IHdpdGggc2VnbWVudHMgZGF0YVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgR3JhcGggb2YgYWxsIHBvc3NpYmxlIHNlZ21lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVpbGRHcmFwaChub2RlcywgdmVyc2lvbikge1xuICAgICAgICB2YXIgdGFibGUgPSB7fTtcbiAgICAgICAgdmFyIGdyYXBoID0geyAnc3RhcnQnOiB7fSB9O1xuICAgICAgICB2YXIgcHJldk5vZGVJZHMgPSBbJ3N0YXJ0J107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlR3JvdXAgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZUlkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlR3JvdXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVHcm91cFtqXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJycgKyBpICsgajtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUlkcy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgdGFibGVba2V5XSA9IHsgbm9kZTogbm9kZSwgbGFzdENvdW50OiAwIH07XG4gICAgICAgICAgICAgICAgZ3JhcGhba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcHJldk5vZGVJZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZOb2RlSWQgPSBwcmV2Tm9kZUlkc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlW3ByZXZOb2RlSWRdICYmIHRhYmxlW3ByZXZOb2RlSWRdLm5vZGUubW9kZSA9PT0gbm9kZS5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaFtwcmV2Tm9kZUlkXVtrZXldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTZWdtZW50Qml0c0xlbmd0aCh0YWJsZVtwcmV2Tm9kZUlkXS5sYXN0Q291bnQgKyBub2RlLmxlbmd0aCwgbm9kZS5tb2RlKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFNlZ21lbnRCaXRzTGVuZ3RoKHRhYmxlW3ByZXZOb2RlSWRdLmxhc3RDb3VudCwgbm9kZS5tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlW3ByZXZOb2RlSWRdLmxhc3RDb3VudCArPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwcmV2Tm9kZUlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVtwcmV2Tm9kZUlkXS5sYXN0Q291bnQgPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoW3ByZXZOb2RlSWRdW2tleV0gPSBnZXRTZWdtZW50Qml0c0xlbmd0aChub2RlLmxlbmd0aCwgbm9kZS5tb2RlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCArIG1vZGUuZ2V0Q2hhckNvdW50SW5kaWNhdG9yKG5vZGUubW9kZSwgdmVyc2lvbik7IC8vIHN3aXRjaCBjb3N0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2Tm9kZUlkcyA9IGN1cnJlbnROb2RlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBwcmV2Tm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgZ3JhcGhbcHJldk5vZGVJZHNbbl1dWydlbmQnXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwOiBncmFwaCwgdGFibGU6IHRhYmxlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIHNlZ21lbnQgZnJvbSBhIHNwZWNpZmllZCBkYXRhIGFuZCBtb2RlLlxuICAgICAqIElmIGEgbW9kZSBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbW9yZSBzdWl0YWJsZSB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICAgICAgICAgICAgSW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSAge01vZGUgfCBTdHJpbmd9IG1vZGVzSGludCBEYXRhIG1vZGVcbiAgICAgKiBAcmV0dXJuIHtTZWdtZW50fSAgICAgICAgICAgICAgICAgU2VnbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ1aWxkU2luZ2xlU2VnbWVudChkYXRhLCBtb2Rlc0hpbnQpIHtcbiAgICAgICAgdmFyIG1vZGUkMTtcbiAgICAgICAgdmFyIGJlc3RNb2RlID0gbW9kZS5nZXRCZXN0TW9kZUZvckRhdGEoZGF0YSk7XG4gICAgICAgIG1vZGUkMSA9IG1vZGUuZnJvbShtb2Rlc0hpbnQsIGJlc3RNb2RlKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGRhdGEgY2FuIGJlIGVuY29kZWRcbiAgICAgICAgaWYgKG1vZGUkMSAhPT0gbW9kZS5CWVRFICYmIG1vZGUkMS5iaXQgPCBiZXN0TW9kZS5iaXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgZGF0YSArICdcIicgK1xuICAgICAgICAgICAgICAgICcgY2Fubm90IGJlIGVuY29kZWQgd2l0aCBtb2RlICcgKyBtb2RlLnRvU3RyaW5nKG1vZGUkMSkgK1xuICAgICAgICAgICAgICAgICcuXFxuIFN1Z2dlc3RlZCBtb2RlIGlzOiAnICsgbW9kZS50b1N0cmluZyhiZXN0TW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBNb2RlLkJZVEUgaWYgS2Fuamkgc3VwcG9ydCBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAobW9kZSQxID09PSBtb2RlLktBTkpJICYmICF1dGlscy5pc0thbmppTW9kZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgbW9kZSQxID0gbW9kZS5CWVRFO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobW9kZSQxKSB7XG4gICAgICAgICAgICBjYXNlIG1vZGUuTlVNRVJJQzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG51bWVyaWNEYXRhKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSBtb2RlLkFMUEhBTlVNRVJJQzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFscGhhbnVtZXJpY0RhdGEoZGF0YSk7XG4gICAgICAgICAgICBjYXNlIG1vZGUuS0FOSkk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBrYW5qaURhdGEoZGF0YSk7XG4gICAgICAgICAgICBjYXNlIG1vZGUuQllURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJ5dGVEYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGxpc3Qgb2Ygc2VnbWVudHMgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBBcnJheSBjYW4gY29udGFpbiBTdHJpbmdzIG9yIE9iamVjdHMgd2l0aCBzZWdtZW50J3MgaW5mby5cbiAgICAgKlxuICAgICAqIEZvciBlYWNoIGl0ZW0gd2hpY2ggaXMgYSBzdHJpbmcsIHdpbGwgYmUgZ2VuZXJhdGVkIGEgc2VnbWVudCB3aXRoIHRoZSBnaXZlblxuICAgICAqIHN0cmluZyBhbmQgdGhlIG1vcmUgYXBwcm9wcmlhdGUgZW5jb2RpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqIEZvciBlYWNoIGl0ZW0gd2hpY2ggaXMgYW4gb2JqZWN0LCB3aWxsIGJlIGdlbmVyYXRlZCBhIHNlZ21lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBkYXRhIGFuZCBtb2RlLlxuICAgICAqIE9iamVjdHMgbXVzdCBjb250YWluIGF0IGxlYXN0IHRoZSBwcm9wZXJ0eSBcImRhdGFcIi5cbiAgICAgKiBJZiBwcm9wZXJ0eSBcIm1vZGVcIiBpcyBub3QgcHJlc2VudCwgdGhlIG1vcmUgc3VpdGFibGUgbW9kZSB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXkgQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNlZ21lbnRzIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQXJyYXkgb2YgU2VnbWVudHNcbiAgICAgKi9cbiAgICBleHBvcnRzLmZyb21BcnJheSA9IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNlZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goYnVpbGRTaW5nbGVTZWdtZW50KHNlZywgbnVsbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChidWlsZFNpbmdsZVNlZ21lbnQoc2VnLmRhdGEsIHNlZy5tb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gb3B0aW1pemVkIHNlcXVlbmNlIG9mIHNlZ21lbnRzIGZyb20gYSBzdHJpbmcsXG4gICAgICogd2hpY2ggd2lsbCBwcm9kdWNlIHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBiaXRzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICAgSW5wdXQgc3RyaW5nXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSBvZiBzZWdtZW50c1xuICAgICAqL1xuICAgIGV4cG9ydHMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoZGF0YSwgdmVyc2lvbikge1xuICAgICAgICB2YXIgc2VncyA9IGdldFNlZ21lbnRzRnJvbVN0cmluZyhkYXRhLCB1dGlscy5pc0thbmppTW9kZUVuYWJsZWQoKSk7XG4gICAgICAgIHZhciBub2RlcyA9IGJ1aWxkTm9kZXMoc2Vncyk7XG4gICAgICAgIHZhciBncmFwaCA9IGJ1aWxkR3JhcGgobm9kZXMsIHZlcnNpb24pO1xuICAgICAgICB2YXIgcGF0aCA9IGRpamtzdHJhXzEuZmluZF9wYXRoKGdyYXBoLm1hcCwgJ3N0YXJ0JywgJ2VuZCcpO1xuICAgICAgICB2YXIgb3B0aW1pemVkU2VncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBvcHRpbWl6ZWRTZWdzLnB1c2goZ3JhcGgudGFibGVbcGF0aFtpXV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZnJvbUFycmF5KG1lcmdlU2VnbWVudHMob3B0aW1pemVkU2VncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgc3RyaW5nIGluIHZhcmlvdXMgc2VnbWVudHMgd2l0aCB0aGUgbW9kZXMgd2hpY2hcbiAgICAgKiBiZXN0IHJlcHJlc2VudCB0aGVpciBjb250ZW50LlxuICAgICAqIFRoZSBwcm9kdWNlZCBzZWdtZW50cyBhcmUgZmFyIGZyb20gYmVpbmcgb3B0aW1pemVkLlxuICAgICAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgdG8gZXN0aW1hdGUgYSBRUiBDb2RlIHZlcnNpb25cbiAgICAgKiB3aGljaCBtYXkgY29udGFpbiB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZGF0YSBJbnB1dCBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQXJyYXkgb2Ygc2VnbWVudHNcbiAgICAgKi9cbiAgICBleHBvcnRzLnJhd1NwbGl0ID0gZnVuY3Rpb24gcmF3U3BsaXQoZGF0YSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5mcm9tQXJyYXkoZ2V0U2VnbWVudHNGcm9tU3RyaW5nKGRhdGEsIHV0aWxzLmlzS2FuamlNb2RlRW5hYmxlZCgpKSk7XG4gICAgfTtcbn0pO1xuLyoqXG4gKiBRUkNvZGUgZm9yIEphdmFTY3JpcHRcbiAqXG4gKiBtb2RpZmllZCBieSBSeWFuIERheSBmb3Igbm9kZWpzIHN1cHBvcnRcbiAqIENvcHlyaWdodCAoYykgMjAxMSBSeWFuIERheVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUVJDb2RlIGZvciBKYXZhU2NyaXB0XG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDA5IEthenVoaWtvIEFyYXNlXG4vL1xuLy8gVVJMOiBodHRwOi8vd3d3LmQtcHJvamVjdC5jb20vXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuLy8gICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuLy9cbi8vIFRoZSB3b3JkIFwiUVIgQ29kZVwiIGlzIHJlZ2lzdGVyZWQgdHJhZGVtYXJrIG9mXG4vLyBERU5TTyBXQVZFIElOQ09SUE9SQVRFRFxuLy8gICBodHRwOi8vd3d3LmRlbnNvLXdhdmUuY29tL3FyY29kZS9mYXFwYXRlbnQtZS5odG1sXG4vL1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4vKipcbiAqIEFkZCBmaW5kZXIgcGF0dGVybnMgYml0cyB0byBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge051bWJlcn0gICAgdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gc2V0dXBGaW5kZXJQYXR0ZXJuKG1hdHJpeCwgdmVyc2lvbikge1xuICAgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG4gICAgdmFyIHBvcyA9IGZpbmRlclBhdHRlcm4uZ2V0UG9zaXRpb25zKHZlcnNpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb3cgPSBwb3NbaV1bMF07XG4gICAgICAgIHZhciBjb2wgPSBwb3NbaV1bMV07XG4gICAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSA3OyByKyspIHtcbiAgICAgICAgICAgIGlmIChyb3cgKyByIDw9IC0xIHx8IHNpemUgPD0gcm93ICsgcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sICsgYyA8PSAtMSB8fCBzaXplIDw9IGNvbCArIGMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICgociA+PSAwICYmIHIgPD0gNiAmJiAoYyA9PT0gMCB8fCBjID09PSA2KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGMgPj0gMCAmJiBjIDw9IDYgJiYgKHIgPT09IDAgfHwgciA9PT0gNikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChyID49IDIgJiYgciA8PSA0ICYmIGMgPj0gMiAmJiBjIDw9IDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQocm93ICsgciwgY29sICsgYywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHJvdyArIHIsIGNvbCArIGMsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFkZCB0aW1pbmcgcGF0dGVybiBiaXRzIHRvIG1hdHJpeFxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBzZXR1cEFsaWdubWVudFBhdHRlcm59XG4gKlxuICogQHBhcmFtICB7Qml0TWF0cml4fSBtYXRyaXggTW9kdWxlcyBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc2V0dXBUaW1pbmdQYXR0ZXJuKG1hdHJpeCkge1xuICAgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG4gICAgZm9yICh2YXIgciA9IDg7IHIgPCBzaXplIC0gODsgcisrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHIgJSAyID09PSAwO1xuICAgICAgICBtYXRyaXguc2V0KHIsIDYsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgbWF0cml4LnNldCg2LCByLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBZGQgYWxpZ25tZW50IHBhdHRlcm5zIGJpdHMgdG8gbWF0cml4XG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBhZnRlciB7QGxpbmsgc2V0dXBUaW1pbmdQYXR0ZXJufVxuICpcbiAqIEBwYXJhbSAge0JpdE1hdHJpeH0gbWF0cml4ICBNb2R1bGVzIG1hdHJpeFxuICogQHBhcmFtICB7TnVtYmVyfSAgICB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuICovXG5mdW5jdGlvbiBzZXR1cEFsaWdubWVudFBhdHRlcm4obWF0cml4LCB2ZXJzaW9uKSB7XG4gICAgdmFyIHBvcyA9IGFsaWdubWVudFBhdHRlcm4uZ2V0UG9zaXRpb25zKHZlcnNpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb3cgPSBwb3NbaV1bMF07XG4gICAgICAgIHZhciBjb2wgPSBwb3NbaV1bMV07XG4gICAgICAgIGZvciAodmFyIHIgPSAtMjsgciA8PSAyOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMjsgYyA8PSAyOyBjKyspIHtcbiAgICAgICAgICAgICAgICBpZiAociA9PT0gLTIgfHwgciA9PT0gMiB8fCBjID09PSAtMiB8fCBjID09PSAyIHx8XG4gICAgICAgICAgICAgICAgICAgIChyID09PSAwICYmIGMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQocm93ICsgciwgY29sICsgYywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHJvdyArIHIsIGNvbCArIGMsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFkZCB2ZXJzaW9uIGluZm8gYml0cyB0byBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge051bWJlcn0gICAgdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gc2V0dXBWZXJzaW9uSW5mbyhtYXRyaXgsIHZlcnNpb24kMSkge1xuICAgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG4gICAgdmFyIGJpdHMgPSB2ZXJzaW9uLmdldEVuY29kZWRCaXRzKHZlcnNpb24kMSk7XG4gICAgdmFyIHJvdywgY29sLCBtb2Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgICAgIHJvdyA9IE1hdGguZmxvb3IoaSAvIDMpO1xuICAgICAgICBjb2wgPSBpICUgMyArIHNpemUgLSA4IC0gMztcbiAgICAgICAgbW9kID0gKChiaXRzID4+IGkpICYgMSkgPT09IDE7XG4gICAgICAgIG1hdHJpeC5zZXQocm93LCBjb2wsIG1vZCwgdHJ1ZSk7XG4gICAgICAgIG1hdHJpeC5zZXQoY29sLCByb3csIG1vZCwgdHJ1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBZGQgZm9ybWF0IGluZm8gYml0cyB0byBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgICAgICAgICAgICAgIE1vZHVsZXMgbWF0cml4XG4gKiBAcGFyYW0gIHtFcnJvckNvcnJlY3Rpb25MZXZlbH0gICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICogQHBhcmFtICB7TnVtYmVyfSAgICBtYXNrUGF0dGVybiAgICAgICAgICBNYXNrIHBhdHRlcm4gcmVmZXJlbmNlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRm9ybWF0SW5mbyhtYXRyaXgsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybikge1xuICAgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG4gICAgdmFyIGJpdHMgPSBmb3JtYXRJbmZvLmdldEVuY29kZWRCaXRzKGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybik7XG4gICAgdmFyIGksIG1vZDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgICAgICBtb2QgPSAoKGJpdHMgPj4gaSkgJiAxKSA9PT0gMTtcbiAgICAgICAgLy8gdmVydGljYWxcbiAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGksIDgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDgpIHtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoaSArIDEsIDgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXguc2V0KHNpemUgLSAxNSArIGksIDgsIG1vZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICBpZiAoaSA8IDgpIHtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoOCwgc2l6ZSAtIGkgLSAxLCBtb2QsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCA5KSB7XG4gICAgICAgICAgICBtYXRyaXguc2V0KDgsIDE1IC0gaSAtIDEgKyAxLCBtb2QsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0cml4LnNldCg4LCAxNSAtIGkgLSAxLCBtb2QsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZpeGVkIG1vZHVsZVxuICAgIG1hdHJpeC5zZXQoc2l6ZSAtIDgsIDgsIDEsIHRydWUpO1xufVxuLyoqXG4gKiBBZGQgZW5jb2RlZCBkYXRhIGJpdHMgdG8gbWF0cml4XG4gKlxuICogQHBhcmFtICB7Qml0TWF0cml4fSBtYXRyaXggTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge0J1ZmZlcn0gICAgZGF0YSAgIERhdGEgY29kZXdvcmRzXG4gKi9cbmZ1bmN0aW9uIHNldHVwRGF0YShtYXRyaXgsIGRhdGEpIHtcbiAgICB2YXIgc2l6ZSA9IG1hdHJpeC5zaXplO1xuICAgIHZhciBpbmMgPSAtMTtcbiAgICB2YXIgcm93ID0gc2l6ZSAtIDE7XG4gICAgdmFyIGJpdEluZGV4ID0gNztcbiAgICB2YXIgYnl0ZUluZGV4ID0gMDtcbiAgICBmb3IgKHZhciBjb2wgPSBzaXplIC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcbiAgICAgICAgaWYgKGNvbCA9PT0gNilcbiAgICAgICAgICAgIGNvbC0tO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdHJpeC5pc1Jlc2VydmVkKHJvdywgY29sIC0gYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhcmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVJbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXJrID0gKCgoZGF0YVtieXRlSW5kZXhdID4+PiBiaXRJbmRleCkgJiAxKSA9PT0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChyb3csIGNvbCAtIGMsIGRhcmspO1xuICAgICAgICAgICAgICAgICAgICBiaXRJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEluZGV4ID0gNztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdyArPSBpbmM7XG4gICAgICAgICAgICBpZiAocm93IDwgMCB8fCBzaXplIDw9IHJvdykge1xuICAgICAgICAgICAgICAgIHJvdyAtPSBpbmM7XG4gICAgICAgICAgICAgICAgaW5jID0gLWluYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGVuY29kZWQgY29kZXdvcmRzIGZyb20gZGF0YSBpbnB1dFxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gICB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAqIEBwYXJhbSAge0Vycm9yQ29ycmVjdGlvbkxldmVsfSAgIGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAqIEBwYXJhbSAge0J5dGVEYXRhfSBkYXRhICAgICAgICAgICAgICAgICBEYXRhIGlucHV0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyIGNvbnRhaW5pbmcgZW5jb2RlZCBjb2Rld29yZHNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGF0YSh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgc2VnbWVudHMpIHtcbiAgICAvLyBQcmVwYXJlIGRhdGEgYnVmZmVyXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBiaXRCdWZmZXIoKTtcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHByZWZpeCBkYXRhIHdpdGggbW9kZSBpbmRpY2F0b3IgKDQgYml0cylcbiAgICAgICAgYnVmZmVyLnB1dChkYXRhLm1vZGUuYml0LCA0KTtcbiAgICAgICAgLy8gUHJlZml4IGRhdGEgd2l0aCBjaGFyYWN0ZXIgY291bnQgaW5kaWNhdG9yLlxuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGNvdW50IGluZGljYXRvciBpcyBhIHN0cmluZyBvZiBiaXRzIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgICAgICAgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgYmVpbmcgZW5jb2RlZC5cbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBjb3VudCBpbmRpY2F0b3IgbXVzdCBiZSBwbGFjZWQgYWZ0ZXIgdGhlIG1vZGUgaW5kaWNhdG9yXG4gICAgICAgIC8vIGFuZCBtdXN0IGJlIGEgY2VydGFpbiBudW1iZXIgb2YgYml0cyBsb25nLCBkZXBlbmRpbmcgb24gdGhlIFFSIHZlcnNpb25cbiAgICAgICAgLy8gYW5kIGRhdGEgbW9kZVxuICAgICAgICAvLyBAc2VlIHtAbGluayBNb2RlLmdldENoYXJDb3VudEluZGljYXRvcn0uXG4gICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgbW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3IoZGF0YS5tb2RlLCB2ZXJzaW9uKSk7XG4gICAgICAgIC8vIGFkZCBiaW5hcnkgZGF0YSBzZXF1ZW5jZSB0byBidWZmZXJcbiAgICAgICAgZGF0YS53cml0ZShidWZmZXIpO1xuICAgIH0pO1xuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBudW1iZXIgb2YgYml0c1xuICAgIHZhciB0b3RhbENvZGV3b3JkcyA9IHV0aWxzLmdldFN5bWJvbFRvdGFsQ29kZXdvcmRzKHZlcnNpb24pO1xuICAgIHZhciBlY1RvdGFsQ29kZXdvcmRzID0gZXJyb3JDb3JyZWN0aW9uQ29kZS5nZXRUb3RhbENvZGV3b3Jkc0NvdW50KHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICB2YXIgZGF0YVRvdGFsQ29kZXdvcmRzQml0cyA9ICh0b3RhbENvZGV3b3JkcyAtIGVjVG90YWxDb2Rld29yZHMpICogODtcbiAgICAvLyBBZGQgYSB0ZXJtaW5hdG9yLlxuICAgIC8vIElmIHRoZSBiaXQgc3RyaW5nIGlzIHNob3J0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIHJlcXVpcmVkIGJpdHMsXG4gICAgLy8gYSB0ZXJtaW5hdG9yIG9mIHVwIHRvIGZvdXIgMHMgbXVzdCBiZSBhZGRlZCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3RyaW5nLlxuICAgIC8vIElmIHRoZSBiaXQgc3RyaW5nIGlzIG1vcmUgdGhhbiBmb3VyIGJpdHMgc2hvcnRlciB0aGFuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgYml0cyxcbiAgICAvLyBhZGQgZm91ciAwcyB0byB0aGUgZW5kLlxuICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMpIHtcbiAgICAgICAgYnVmZmVyLnB1dCgwLCA0KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGJpdCBzdHJpbmcgaXMgZmV3ZXIgdGhhbiBmb3VyIGJpdHMgc2hvcnRlciwgYWRkIG9ubHkgdGhlIG51bWJlciBvZiAwcyB0aGF0XG4gICAgLy8gYXJlIG5lZWRlZCB0byByZWFjaCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGJpdHMuXG4gICAgLy8gQWZ0ZXIgYWRkaW5nIHRoZSB0ZXJtaW5hdG9yLCBpZiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIHN0cmluZyBpcyBub3QgYSBtdWx0aXBsZSBvZiA4LFxuICAgIC8vIHBhZCB0aGUgc3RyaW5nIG9uIHRoZSByaWdodCB3aXRoIDBzIHRvIG1ha2UgdGhlIHN0cmluZydzIGxlbmd0aCBhIG11bHRpcGxlIG9mIDguXG4gICAgd2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT09IDApIHtcbiAgICAgICAgYnVmZmVyLnB1dEJpdCgwKTtcbiAgICB9XG4gICAgLy8gQWRkIHBhZCBieXRlcyBpZiB0aGUgc3RyaW5nIGlzIHN0aWxsIHNob3J0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIHJlcXVpcmVkIGJpdHMuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgdG8gZmlsbCB0aGUgZGF0YSBjYXBhY2l0eSBvZiB0aGUgc3ltYm9sIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAvLyB0aGUgVmVyc2lvbiBhbmQgRXJyb3IgQ29ycmVjdGlvbiBMZXZlbCBieSBhZGRpbmcgdGhlIFBhZCBDb2Rld29yZHMgMTExMDExMDAgKDB4RUMpXG4gICAgLy8gYW5kIDAwMDEwMDAxICgweDExKSBhbHRlcm5hdGVseS5cbiAgICB2YXIgcmVtYWluaW5nQnl0ZSA9IChkYXRhVG90YWxDb2Rld29yZHNCaXRzIC0gYnVmZmVyLmdldExlbmd0aEluQml0cygpKSAvIDg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5pbmdCeXRlOyBpKyspIHtcbiAgICAgICAgYnVmZmVyLnB1dChpICUgMiA/IDB4MTEgOiAweEVDLCA4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNvZGV3b3JkcyhidWZmZXIsIHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbn1cbi8qKlxuICogRW5jb2RlIGlucHV0IGRhdGEgd2l0aCBSZWVkLVNvbG9tb24gYW5kIHJldHVybiBjb2Rld29yZHMgd2l0aFxuICogcmVsYXRpdmUgZXJyb3IgY29ycmVjdGlvbiBiaXRzXG4gKlxuICogQHBhcmFtICB7Qml0QnVmZmVyfSBiaXRCdWZmZXIgICAgICAgICAgICBEYXRhIHRvIGVuY29kZVxuICogQHBhcmFtICB7TnVtYmVyfSAgICB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAqIEBwYXJhbSAge0Vycm9yQ29ycmVjdGlvbkxldmVsfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gKiBAcmV0dXJuIHtCdWZmZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlciBjb250YWluaW5nIGVuY29kZWQgY29kZXdvcmRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvZGV3b3JkcyhiaXRCdWZmZXIsIHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgLy8gVG90YWwgY29kZXdvcmRzIGZvciB0aGlzIFFSIGNvZGUgdmVyc2lvbiAoRGF0YSArIEVycm9yIGNvcnJlY3Rpb24pXG4gICAgdmFyIHRvdGFsQ29kZXdvcmRzID0gdXRpbHMuZ2V0U3ltYm9sVG90YWxDb2Rld29yZHModmVyc2lvbik7XG4gICAgLy8gVG90YWwgbnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgdmFyIGVjVG90YWxDb2Rld29yZHMgPSBlcnJvckNvcnJlY3Rpb25Db2RlLmdldFRvdGFsQ29kZXdvcmRzQ291bnQodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgIC8vIFRvdGFsIG51bWJlciBvZiBkYXRhIGNvZGV3b3Jkc1xuICAgIHZhciBkYXRhVG90YWxDb2Rld29yZHMgPSB0b3RhbENvZGV3b3JkcyAtIGVjVG90YWxDb2Rld29yZHM7XG4gICAgLy8gVG90YWwgbnVtYmVyIG9mIGJsb2Nrc1xuICAgIHZhciBlY1RvdGFsQmxvY2tzID0gZXJyb3JDb3JyZWN0aW9uQ29kZS5nZXRCbG9ja3NDb3VudCh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG4gICAgLy8gQ2FsY3VsYXRlIGhvdyBtYW55IGJsb2NrcyBlYWNoIGdyb3VwIHNob3VsZCBjb250YWluXG4gICAgdmFyIGJsb2Nrc0luR3JvdXAyID0gdG90YWxDb2Rld29yZHMgJSBlY1RvdGFsQmxvY2tzO1xuICAgIHZhciBibG9ja3NJbkdyb3VwMSA9IGVjVG90YWxCbG9ja3MgLSBibG9ja3NJbkdyb3VwMjtcbiAgICB2YXIgdG90YWxDb2Rld29yZHNJbkdyb3VwMSA9IE1hdGguZmxvb3IodG90YWxDb2Rld29yZHMgLyBlY1RvdGFsQmxvY2tzKTtcbiAgICB2YXIgZGF0YUNvZGV3b3Jkc0luR3JvdXAxID0gTWF0aC5mbG9vcihkYXRhVG90YWxDb2Rld29yZHMgLyBlY1RvdGFsQmxvY2tzKTtcbiAgICB2YXIgZGF0YUNvZGV3b3Jkc0luR3JvdXAyID0gZGF0YUNvZGV3b3Jkc0luR3JvdXAxICsgMTtcbiAgICAvLyBOdW1iZXIgb2YgRUMgY29kZXdvcmRzIGlzIHRoZSBzYW1lIGZvciBib3RoIGdyb3Vwc1xuICAgIHZhciBlY0NvdW50ID0gdG90YWxDb2Rld29yZHNJbkdyb3VwMSAtIGRhdGFDb2Rld29yZHNJbkdyb3VwMTtcbiAgICAvLyBJbml0aWFsaXplIGEgUmVlZC1Tb2xvbW9uIGVuY29kZXIgd2l0aCBhIGdlbmVyYXRvciBwb2x5bm9taWFsIG9mIGRlZ3JlZSBlY0NvdW50XG4gICAgdmFyIHJzID0gbmV3IHJlZWRTb2xvbW9uRW5jb2RlcihlY0NvdW50KTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgZGNEYXRhID0gbmV3IEFycmF5KGVjVG90YWxCbG9ja3MpO1xuICAgIHZhciBlY0RhdGEgPSBuZXcgQXJyYXkoZWNUb3RhbEJsb2Nrcyk7XG4gICAgdmFyIG1heERhdGFTaXplID0gMDtcbiAgICB2YXIgYnVmZmVyID0gdHlwZWRhcnJheUJ1ZmZlci5mcm9tKGJpdEJ1ZmZlci5idWZmZXIpO1xuICAgIC8vIERpdmlkZSB0aGUgYnVmZmVyIGludG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBibG9ja3NcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGVjVG90YWxCbG9ja3M7IGIrKykge1xuICAgICAgICB2YXIgZGF0YVNpemUgPSBiIDwgYmxvY2tzSW5Hcm91cDEgPyBkYXRhQ29kZXdvcmRzSW5Hcm91cDEgOiBkYXRhQ29kZXdvcmRzSW5Hcm91cDI7XG4gICAgICAgIC8vIGV4dHJhY3QgYSBibG9jayBvZiBkYXRhIGZyb20gYnVmZmVyXG4gICAgICAgIGRjRGF0YVtiXSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGRhdGFTaXplKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIEVDIGNvZGV3b3JkcyBmb3IgdGhpcyBkYXRhIGJsb2NrXG4gICAgICAgIGVjRGF0YVtiXSA9IHJzLmVuY29kZShkY0RhdGFbYl0pO1xuICAgICAgICBvZmZzZXQgKz0gZGF0YVNpemU7XG4gICAgICAgIG1heERhdGFTaXplID0gTWF0aC5tYXgobWF4RGF0YVNpemUsIGRhdGFTaXplKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGZpbmFsIGRhdGFcbiAgICAvLyBJbnRlcmxlYXZlIHRoZSBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3JkcyBmcm9tIGVhY2ggYmxvY2tcbiAgICB2YXIgZGF0YSA9IHR5cGVkYXJyYXlCdWZmZXIuYWxsb2ModG90YWxDb2Rld29yZHMpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGksIHI7XG4gICAgLy8gQWRkIGRhdGEgY29kZXdvcmRzXG4gICAgZm9yIChpID0gMDsgaSA8IG1heERhdGFTaXplOyBpKyspIHtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IGVjVG90YWxCbG9ja3M7IHIrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBkY0RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleCsrXSA9IGRjRGF0YVtyXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBlZCBFQyBjb2Rld29yZHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgZWNDb3VudDsgaSsrKSB7XG4gICAgICAgIGZvciAociA9IDA7IHIgPCBlY1RvdGFsQmxvY2tzOyByKyspIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXgrK10gPSBlY0RhdGFbcl1baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIEJ1aWxkIFFSIENvZGUgc3ltYm9sXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBkYXRhICAgICAgICAgICAgICAgICBJbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcGFyYW0gIHtFcnJvckNvcnJldGlvbkxldmVsfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBsZXZlbFxuICogQHBhcmFtICB7TWFza1BhdHRlcm59IG1hc2tQYXR0ZXJuICAgICBNYXNrIHBhdHRlcm5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgc3ltYm9sIGRhdGFcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3ltYm9sKGRhdGEsIHZlcnNpb24kMSwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIG1hc2tQYXR0ZXJuJDEpIHtcbiAgICB2YXIgc2VnbWVudHMkMTtcbiAgICBpZiAoaXNhcnJheShkYXRhKSkge1xuICAgICAgICBzZWdtZW50cyQxID0gc2VnbWVudHMuZnJvbUFycmF5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGVzdGltYXRlZFZlcnNpb24gPSB2ZXJzaW9uJDE7XG4gICAgICAgIGlmICghZXN0aW1hdGVkVmVyc2lvbikge1xuICAgICAgICAgICAgdmFyIHJhd1NlZ21lbnRzID0gc2VnbWVudHMucmF3U3BsaXQoZGF0YSk7XG4gICAgICAgICAgICAvLyBFc3RpbWF0ZSBiZXN0IHZlcnNpb24gdGhhdCBjYW4gY29udGFpbiByYXcgc3BsaXR0ZWQgc2VnbWVudHNcbiAgICAgICAgICAgIGVzdGltYXRlZFZlcnNpb24gPSB2ZXJzaW9uLmdldEJlc3RWZXJzaW9uRm9yRGF0YShyYXdTZWdtZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIG9wdGltaXplZCBzZWdtZW50c1xuICAgICAgICAvLyBJZiBlc3RpbWF0ZWQgdmVyc2lvbiBpcyB1bmRlZmluZWQsIHRyeSB3aXRoIHRoZSBoaWdoZXN0IHZlcnNpb25cbiAgICAgICAgc2VnbWVudHMkMSA9IHNlZ21lbnRzLmZyb21TdHJpbmcoZGF0YSwgZXN0aW1hdGVkVmVyc2lvbiB8fCA0MCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIG1pbiB2ZXJzaW9uIHRoYXQgY2FuIGNvbnRhaW4gZGF0YVxuICAgIHZhciBiZXN0VmVyc2lvbiA9IHZlcnNpb24uZ2V0QmVzdFZlcnNpb25Gb3JEYXRhKHNlZ21lbnRzJDEsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICAvLyBJZiBubyB2ZXJzaW9uIGlzIGZvdW5kLCBkYXRhIGNhbm5vdCBiZSBzdG9yZWRcbiAgICBpZiAoIWJlc3RWZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFtb3VudCBvZiBkYXRhIGlzIHRvbyBiaWcgdG8gYmUgc3RvcmVkIGluIGEgUVIgQ29kZScpO1xuICAgIH1cbiAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgbWluIHZlcnNpb24gYXMgZGVmYXVsdFxuICAgIGlmICghdmVyc2lvbiQxKSB7XG4gICAgICAgIHZlcnNpb24kMSA9IGJlc3RWZXJzaW9uO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIHZlcnNpb24gY2FuIGNvbnRhaW4gdGhlIGRhdGFcbiAgICB9XG4gICAgZWxzZSBpZiAodmVyc2lvbiQxIDwgYmVzdFZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXG4nICtcbiAgICAgICAgICAgICdUaGUgY2hvc2VuIFFSIENvZGUgdmVyc2lvbiBjYW5ub3QgY29udGFpbiB0aGlzIGFtb3VudCBvZiBkYXRhLlxcbicgK1xuICAgICAgICAgICAgJ01pbmltdW0gdmVyc2lvbiByZXF1aXJlZCB0byBzdG9yZSBjdXJyZW50IGRhdGEgaXM6ICcgKyBiZXN0VmVyc2lvbiArICcuXFxuJyk7XG4gICAgfVxuICAgIHZhciBkYXRhQml0cyA9IGNyZWF0ZURhdGEodmVyc2lvbiQxLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgc2VnbWVudHMkMSk7XG4gICAgLy8gQWxsb2NhdGUgbWF0cml4IGJ1ZmZlclxuICAgIHZhciBtb2R1bGVDb3VudCA9IHV0aWxzLmdldFN5bWJvbFNpemUodmVyc2lvbiQxKTtcbiAgICB2YXIgbW9kdWxlcyA9IG5ldyBiaXRNYXRyaXgobW9kdWxlQ291bnQpO1xuICAgIC8vIEFkZCBmdW5jdGlvbiBtb2R1bGVzXG4gICAgc2V0dXBGaW5kZXJQYXR0ZXJuKG1vZHVsZXMsIHZlcnNpb24kMSk7XG4gICAgc2V0dXBUaW1pbmdQYXR0ZXJuKG1vZHVsZXMpO1xuICAgIHNldHVwQWxpZ25tZW50UGF0dGVybihtb2R1bGVzLCB2ZXJzaW9uJDEpO1xuICAgIC8vIEFkZCB0ZW1wb3JhcnkgZHVtbXkgYml0cyBmb3IgZm9ybWF0IGluZm8ganVzdCB0byBzZXQgdGhlbSBhcyByZXNlcnZlZC5cbiAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IHRoZXNlIGJpdHMgZnJvbSBiZWluZyBtYXNrZWQgYnkge0BsaW5rIE1hc2tQYXR0ZXJuLmFwcGx5TWFza31cbiAgICAvLyBzaW5jZSB0aGUgbWFza2luZyBvcGVyYXRpb24gbXVzdCBiZSBwZXJmb3JtZWQgb25seSBvbiB0aGUgZW5jb2RpbmcgcmVnaW9uLlxuICAgIC8vIFRoZXNlIGJsb2NrcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggY29ycmVjdCB2YWx1ZXMgbGF0ZXIgaW4gY29kZS5cbiAgICBzZXR1cEZvcm1hdEluZm8obW9kdWxlcywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIDApO1xuICAgIGlmICh2ZXJzaW9uJDEgPj0gNykge1xuICAgICAgICBzZXR1cFZlcnNpb25JbmZvKG1vZHVsZXMsIHZlcnNpb24kMSk7XG4gICAgfVxuICAgIC8vIEFkZCBkYXRhIGNvZGV3b3Jkc1xuICAgIHNldHVwRGF0YShtb2R1bGVzLCBkYXRhQml0cyk7XG4gICAgaWYgKGlzTmFOKG1hc2tQYXR0ZXJuJDEpKSB7XG4gICAgICAgIC8vIEZpbmQgYmVzdCBtYXNrIHBhdHRlcm5cbiAgICAgICAgbWFza1BhdHRlcm4kMSA9IG1hc2tQYXR0ZXJuLmdldEJlc3RNYXNrKG1vZHVsZXMsIHNldHVwRm9ybWF0SW5mby5iaW5kKG51bGwsIG1vZHVsZXMsIGVycm9yQ29ycmVjdGlvbkxldmVsKSk7XG4gICAgfVxuICAgIC8vIEFwcGx5IG1hc2sgcGF0dGVyblxuICAgIG1hc2tQYXR0ZXJuLmFwcGx5TWFzayhtYXNrUGF0dGVybiQxLCBtb2R1bGVzKTtcbiAgICAvLyBSZXBsYWNlIGZvcm1hdCBpbmZvIGJpdHMgd2l0aCBjb3JyZWN0IHZhbHVlc1xuICAgIHNldHVwRm9ybWF0SW5mbyhtb2R1bGVzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgbWFza1BhdHRlcm4kMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9kdWxlczogbW9kdWxlcyxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbiQxLFxuICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbDogZXJyb3JDb3JyZWN0aW9uTGV2ZWwsXG4gICAgICAgIG1hc2tQYXR0ZXJuOiBtYXNrUGF0dGVybiQxLFxuICAgICAgICBzZWdtZW50czogc2VnbWVudHMkMVxuICAgIH07XG59XG4vKipcbiAqIFFSIENvZGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBkYXRhICAgICAgICAgICAgICAgICBJbnB1dCBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBjb25maWd1cmF0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMudmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5lcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRvU0pJU0Z1bmMgICAgICAgICBIZWxwZXIgZnVuYyB0byBjb252ZXJ0IHV0ZjggdG8gc2ppc1xuICovXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnIHx8IGRhdGEgPT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgdGV4dCcpO1xuICAgIH1cbiAgICB2YXIgZXJyb3JDb3JyZWN0aW9uTGV2ZWwkMSA9IGVycm9yQ29ycmVjdGlvbkxldmVsLk07XG4gICAgdmFyIHZlcnNpb24kMTtcbiAgICB2YXIgbWFzaztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFVzZSBoaWdoZXIgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhcyBkZWZhdWx0XG4gICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsJDEgPSBlcnJvckNvcnJlY3Rpb25MZXZlbC5mcm9tKG9wdGlvbnMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGVycm9yQ29ycmVjdGlvbkxldmVsLk0pO1xuICAgICAgICB2ZXJzaW9uJDEgPSB2ZXJzaW9uLmZyb20ob3B0aW9ucy52ZXJzaW9uKTtcbiAgICAgICAgbWFzayA9IG1hc2tQYXR0ZXJuLmZyb20ob3B0aW9ucy5tYXNrUGF0dGVybik7XG4gICAgICAgIGlmIChvcHRpb25zLnRvU0pJU0Z1bmMpIHtcbiAgICAgICAgICAgIHV0aWxzLnNldFRvU0pJU0Z1bmN0aW9uKG9wdGlvbnMudG9TSklTRnVuYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVN5bWJvbChkYXRhLCB2ZXJzaW9uJDEsIGVycm9yQ29ycmVjdGlvbkxldmVsJDEsIG1hc2spO1xufTtcbnZhciBxcmNvZGUgPSB7XG4gICAgY3JlYXRlOiBjcmVhdGVcbn07XG52YXIgdXRpbHMkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBmdW5jdGlvbiBoZXgycmdiYShoZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBoZXggPSBoZXgudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igc2hvdWxkIGJlIGRlZmluZWQgYXMgaGV4IHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZXhDb2RlID0gaGV4LnNsaWNlKCkucmVwbGFjZSgnIycsICcnKS5zcGxpdCgnJyk7XG4gICAgICAgIGlmIChoZXhDb2RlLmxlbmd0aCA8IDMgfHwgaGV4Q29kZS5sZW5ndGggPT09IDUgfHwgaGV4Q29kZS5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IGNvbG9yOiAnICsgaGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGZyb20gc2hvcnQgdG8gbG9uZyBmb3JtIChmZmYgLT4gZmZmZmZmKVxuICAgICAgICBpZiAoaGV4Q29kZS5sZW5ndGggPT09IDMgfHwgaGV4Q29kZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIGhleENvZGUgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBoZXhDb2RlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYywgY107XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGRlZmF1bHQgYWxwaGEgdmFsdWVcbiAgICAgICAgaWYgKGhleENvZGUubGVuZ3RoID09PSA2KVxuICAgICAgICAgICAgaGV4Q29kZS5wdXNoKCdGJywgJ0YnKTtcbiAgICAgICAgdmFyIGhleFZhbHVlID0gcGFyc2VJbnQoaGV4Q29kZS5qb2luKCcnKSwgMTYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogKGhleFZhbHVlID4+IDI0KSAmIDI1NSxcbiAgICAgICAgICAgIGc6IChoZXhWYWx1ZSA+PiAxNikgJiAyNTUsXG4gICAgICAgICAgICBiOiAoaGV4VmFsdWUgPj4gOCkgJiAyNTUsXG4gICAgICAgICAgICBhOiBoZXhWYWx1ZSAmIDI1NSxcbiAgICAgICAgICAgIGhleDogJyMnICsgaGV4Q29kZS5zbGljZSgwLCA2KS5qb2luKCcnKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBleHBvcnRzLmdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbnMuY29sb3IpXG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yID0ge307XG4gICAgICAgIHZhciBtYXJnaW4gPSB0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICBvcHRpb25zLm1hcmdpbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgb3B0aW9ucy5tYXJnaW4gPCAwID8gNCA6IG9wdGlvbnMubWFyZ2luO1xuICAgICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMud2lkdGggPj0gMjEgPyBvcHRpb25zLndpZHRoIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBzY2FsZTogd2lkdGggPyA0IDogc2NhbGUsXG4gICAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAgICAgZGFyazogaGV4MnJnYmEob3B0aW9ucy5jb2xvci5kYXJrIHx8ICcjMDAwMDAwZmYnKSxcbiAgICAgICAgICAgICAgICBsaWdodDogaGV4MnJnYmEob3B0aW9ucy5jb2xvci5saWdodCB8fCAnI2ZmZmZmZmZmJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICByZW5kZXJlck9wdHM6IG9wdGlvbnMucmVuZGVyZXJPcHRzIHx8IHt9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUocXJTaXplLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBvcHRzLndpZHRoICYmIG9wdHMud2lkdGggPj0gcXJTaXplICsgb3B0cy5tYXJnaW4gKiAyXG4gICAgICAgICAgICA/IG9wdHMud2lkdGggLyAocXJTaXplICsgb3B0cy5tYXJnaW4gKiAyKVxuICAgICAgICAgICAgOiBvcHRzLnNjYWxlO1xuICAgIH07XG4gICAgZXhwb3J0cy5nZXRJbWFnZVdpZHRoID0gZnVuY3Rpb24gZ2V0SW1hZ2VXaWR0aChxclNpemUsIG9wdHMpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gZXhwb3J0cy5nZXRTY2FsZShxclNpemUsIG9wdHMpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigocXJTaXplICsgb3B0cy5tYXJnaW4gKiAyKSAqIHNjYWxlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMucXJUb0ltYWdlRGF0YSA9IGZ1bmN0aW9uIHFyVG9JbWFnZURhdGEoaW1nRGF0YSwgcXIsIG9wdHMpIHtcbiAgICAgICAgdmFyIHNpemUgPSBxci5tb2R1bGVzLnNpemU7XG4gICAgICAgIHZhciBkYXRhID0gcXIubW9kdWxlcy5kYXRhO1xuICAgICAgICB2YXIgc2NhbGUgPSBleHBvcnRzLmdldFNjYWxlKHNpemUsIG9wdHMpO1xuICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IE1hdGguZmxvb3IoKHNpemUgKyBvcHRzLm1hcmdpbiAqIDIpICogc2NhbGUpO1xuICAgICAgICB2YXIgc2NhbGVkTWFyZ2luID0gb3B0cy5tYXJnaW4gKiBzY2FsZTtcbiAgICAgICAgdmFyIHBhbGV0dGUgPSBbb3B0cy5jb2xvci5saWdodCwgb3B0cy5jb2xvci5kYXJrXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ltYm9sU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0RzdCA9IChpICogc3ltYm9sU2l6ZSArIGopICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcHhDb2xvciA9IG9wdHMuY29sb3IubGlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gc2NhbGVkTWFyZ2luICYmIGogPj0gc2NhbGVkTWFyZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIGkgPCBzeW1ib2xTaXplIC0gc2NhbGVkTWFyZ2luICYmIGogPCBzeW1ib2xTaXplIC0gc2NhbGVkTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpU3JjID0gTWF0aC5mbG9vcigoaSAtIHNjYWxlZE1hcmdpbikgLyBzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqU3JjID0gTWF0aC5mbG9vcigoaiAtIHNjYWxlZE1hcmdpbikgLyBzY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIHB4Q29sb3IgPSBwYWxldHRlW2RhdGFbaVNyYyAqIHNpemUgKyBqU3JjXSA/IDEgOiAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1nRGF0YVtwb3NEc3QrK10gPSBweENvbG9yLnI7XG4gICAgICAgICAgICAgICAgaW1nRGF0YVtwb3NEc3QrK10gPSBweENvbG9yLmc7XG4gICAgICAgICAgICAgICAgaW1nRGF0YVtwb3NEc3QrK10gPSBweENvbG9yLmI7XG4gICAgICAgICAgICAgICAgaW1nRGF0YVtwb3NEc3RdID0gcHhDb2xvci5hO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xudmFyIGNhbnZhcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBmdW5jdGlvbiBjbGVhckNhbnZhcyhjdHgsIGNhbnZhcywgc2l6ZSkge1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGlmICghY2FudmFzLnN0eWxlKVxuICAgICAgICAgICAgY2FudmFzLnN0eWxlID0ge307XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgICAgICBjYW52YXMud2lkdGggPSBzaXplO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gc2l6ZSArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHNpemUgKyAncHgnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDYW52YXNFbGVtZW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHNwZWNpZnkgYSBjYW52YXMgZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHFyRGF0YSwgY2FudmFzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0gb3B0aW9ucztcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gY2FudmFzO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnICYmICghY2FudmFzIHx8ICFjYW52YXMuZ2V0Q29udGV4dCkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBjYW52YXM7XG4gICAgICAgICAgICBjYW52YXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIGNhbnZhc0VsID0gZ2V0Q2FudmFzRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMgPSB1dGlscyQxLmdldE9wdGlvbnMob3B0cyk7XG4gICAgICAgIHZhciBzaXplID0gdXRpbHMkMS5nZXRJbWFnZVdpZHRoKHFyRGF0YS5tb2R1bGVzLnNpemUsIG9wdHMpO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGltYWdlID0gY3R4LmNyZWF0ZUltYWdlRGF0YShzaXplLCBzaXplKTtcbiAgICAgICAgdXRpbHMkMS5xclRvSW1hZ2VEYXRhKGltYWdlLmRhdGEsIHFyRGF0YSwgb3B0cyk7XG4gICAgICAgIGNsZWFyQ2FudmFzKGN0eCwgY2FudmFzRWwsIHNpemUpO1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZW5kZXJUb0RhdGFVUkwgPSBmdW5jdGlvbiByZW5kZXJUb0RhdGFVUkwocXJEYXRhLCBjYW52YXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnICYmICghY2FudmFzIHx8ICFjYW52YXMuZ2V0Q29udGV4dCkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBjYW52YXM7XG4gICAgICAgICAgICBjYW52YXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgY2FudmFzRWwgPSBleHBvcnRzLnJlbmRlcihxckRhdGEsIGNhbnZhcywgb3B0cyk7XG4gICAgICAgIHZhciB0eXBlID0gb3B0cy50eXBlIHx8ICdpbWFnZS9wbmcnO1xuICAgICAgICB2YXIgcmVuZGVyZXJPcHRzID0gb3B0cy5yZW5kZXJlck9wdHMgfHwge307XG4gICAgICAgIHJldHVybiBjYW52YXNFbC50b0RhdGFVUkwodHlwZSwgcmVuZGVyZXJPcHRzLnF1YWxpdHkpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGdldENvbG9yQXR0cmliKGNvbG9yLCBhdHRyaWIpIHtcbiAgICB2YXIgYWxwaGEgPSBjb2xvci5hIC8gMjU1O1xuICAgIHZhciBzdHIgPSBhdHRyaWIgKyAnPVwiJyArIGNvbG9yLmhleCArICdcIic7XG4gICAgcmV0dXJuIGFscGhhIDwgMVxuICAgICAgICA/IHN0ciArICcgJyArIGF0dHJpYiArICctb3BhY2l0eT1cIicgKyBhbHBoYS50b0ZpeGVkKDIpLnNsaWNlKDEpICsgJ1wiJ1xuICAgICAgICA6IHN0cjtcbn1cbmZ1bmN0aW9uIHN2Z0NtZChjbWQsIHgsIHkpIHtcbiAgICB2YXIgc3RyID0gY21kICsgeDtcbiAgICBpZiAodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBzdHIgKz0gJyAnICsgeTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcXJUb1BhdGgoZGF0YSwgc2l6ZSwgbWFyZ2luKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgbW92ZUJ5ID0gMDtcbiAgICB2YXIgbmV3Um93ID0gZmFsc2U7XG4gICAgdmFyIGxpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29sID0gTWF0aC5mbG9vcihpICUgc2l6ZSk7XG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKGkgLyBzaXplKTtcbiAgICAgICAgaWYgKCFjb2wgJiYgIW5ld1JvdylcbiAgICAgICAgICAgIG5ld1JvdyA9IHRydWU7XG4gICAgICAgIGlmIChkYXRhW2ldKSB7XG4gICAgICAgICAgICBsaW5lTGVuZ3RoKys7XG4gICAgICAgICAgICBpZiAoIShpID4gMCAmJiBjb2wgPiAwICYmIGRhdGFbaSAtIDFdKSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gbmV3Um93XG4gICAgICAgICAgICAgICAgICAgID8gc3ZnQ21kKCdNJywgY29sICsgbWFyZ2luLCAwLjUgKyByb3cgKyBtYXJnaW4pXG4gICAgICAgICAgICAgICAgICAgIDogc3ZnQ21kKCdtJywgbW92ZUJ5LCAwKTtcbiAgICAgICAgICAgICAgICBtb3ZlQnkgPSAwO1xuICAgICAgICAgICAgICAgIG5ld1JvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY29sICsgMSA8IHNpemUgJiYgZGF0YVtpICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBzdmdDbWQoJ2gnLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVCeSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihxckRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIG9wdHMgPSB1dGlscyQxLmdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIHNpemUgPSBxckRhdGEubW9kdWxlcy5zaXplO1xuICAgIHZhciBkYXRhID0gcXJEYXRhLm1vZHVsZXMuZGF0YTtcbiAgICB2YXIgcXJjb2Rlc2l6ZSA9IHNpemUgKyBvcHRzLm1hcmdpbiAqIDI7XG4gICAgdmFyIGJnID0gIW9wdHMuY29sb3IubGlnaHQuYVxuICAgICAgICA/ICcnXG4gICAgICAgIDogJzxwYXRoICcgKyBnZXRDb2xvckF0dHJpYihvcHRzLmNvbG9yLmxpZ2h0LCAnZmlsbCcpICtcbiAgICAgICAgICAgICcgZD1cIk0wIDBoJyArIHFyY29kZXNpemUgKyAndicgKyBxcmNvZGVzaXplICsgJ0gwelwiLz4nO1xuICAgIHZhciBwYXRoID0gJzxwYXRoICcgKyBnZXRDb2xvckF0dHJpYihvcHRzLmNvbG9yLmRhcmssICdzdHJva2UnKSArXG4gICAgICAgICcgZD1cIicgKyBxclRvUGF0aChkYXRhLCBzaXplLCBvcHRzLm1hcmdpbikgKyAnXCIvPic7XG4gICAgdmFyIHZpZXdCb3ggPSAndmlld0JveD1cIicgKyAnMCAwICcgKyBxcmNvZGVzaXplICsgJyAnICsgcXJjb2Rlc2l6ZSArICdcIic7XG4gICAgdmFyIHdpZHRoID0gIW9wdHMud2lkdGggPyAnJyA6ICd3aWR0aD1cIicgKyBvcHRzLndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyBvcHRzLndpZHRoICsgJ1wiICc7XG4gICAgdmFyIHN2Z1RhZyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICsgd2lkdGggKyB2aWV3Qm94ICsgJyBzaGFwZS1yZW5kZXJpbmc9XCJjcmlzcEVkZ2VzXCI+JyArIGJnICsgcGF0aCArICc8L3N2Zz5cXG4nO1xuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IobnVsbCwgc3ZnVGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN2Z1RhZztcbn07XG52YXIgc3ZnVGFnID0ge1xuICAgIHJlbmRlcjogcmVuZGVyXG59O1xuZnVuY3Rpb24gcmVuZGVyQ2FudmFzKHJlbmRlckZ1bmMsIGNhbnZhcywgdGV4dCwgb3B0cywgY2IpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYXJnc051bSA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBpc0xhc3RBcmdDYiA9IHR5cGVvZiBhcmdzW2FyZ3NOdW0gLSAxXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoIWlzTGFzdEFyZ0NiICYmICFjYW5Qcm9taXNlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayByZXF1aXJlZCBhcyBsYXN0IGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChpc0xhc3RBcmdDYikge1xuICAgICAgICBpZiAoYXJnc051bSA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIGZldyBhcmd1bWVudHMgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc051bSA9PT0gMikge1xuICAgICAgICAgICAgY2IgPSB0ZXh0O1xuICAgICAgICAgICAgdGV4dCA9IGNhbnZhcztcbiAgICAgICAgICAgIGNhbnZhcyA9IG9wdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnc051bSA9PT0gMykge1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5nZXRDb250ZXh0ICYmIHR5cGVvZiBjYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjYiA9IG9wdHM7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiID0gb3B0cztcbiAgICAgICAgICAgICAgICBvcHRzID0gdGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gY2FudmFzO1xuICAgICAgICAgICAgICAgIGNhbnZhcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGFyZ3NOdW0gPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBmZXcgYXJndW1lbnRzIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3NOdW0gPT09IDEpIHtcbiAgICAgICAgICAgIHRleHQgPSBjYW52YXM7XG4gICAgICAgICAgICBjYW52YXMgPSBvcHRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3NOdW0gPT09IDIgJiYgIWNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgICAgICBvcHRzID0gdGV4dDtcbiAgICAgICAgICAgIHRleHQgPSBjYW52YXM7XG4gICAgICAgICAgICBjYW52YXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBxcmNvZGUuY3JlYXRlKHRleHQsIG9wdHMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVuZGVyRnVuYyhkYXRhLCBjYW52YXMsIG9wdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRhdGEgPSBxcmNvZGUuY3JlYXRlKHRleHQsIG9wdHMpO1xuICAgICAgICBjYihudWxsLCByZW5kZXJGdW5jKGRhdGEsIGNhbnZhcywgb3B0cykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjYihlKTtcbiAgICB9XG59XG52YXIgY3JlYXRlJDEgPSBxcmNvZGUuY3JlYXRlO1xudmFyIHRvQ2FudmFzID0gcmVuZGVyQ2FudmFzLmJpbmQobnVsbCwgY2FudmFzLnJlbmRlcik7XG52YXIgdG9EYXRhVVJMID0gcmVuZGVyQ2FudmFzLmJpbmQobnVsbCwgY2FudmFzLnJlbmRlclRvRGF0YVVSTCk7XG4vLyBvbmx5IHN2ZyBmb3Igbm93LlxudmFyIHRvU3RyaW5nXzEgPSByZW5kZXJDYW52YXMuYmluZChudWxsLCBmdW5jdGlvbiAoZGF0YSwgXywgb3B0cykge1xuICAgIHJldHVybiBzdmdUYWcucmVuZGVyKGRhdGEsIG9wdHMpO1xufSk7XG52YXIgYnJvd3NlciA9IHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHRvQ2FudmFzOiB0b0NhbnZhcyxcbiAgICB0b0RhdGFVUkw6IHRvRGF0YVVSTCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdfMVxufTtcbnZhciBhbXBsaWZ5VG90cFNldHVwQ3NzID0gXCIudG90cC1zZXR1cHt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW4tYm90dG9tOjMwcHh9LnRvdHAtc2V0dXAgaW1ne2hlaWdodDoxMjhweDt3aWR0aDoxMjhweH1cIjtcbnZhciBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdUT1RQJyk7XG52YXIgQW1wbGlmeVRPVFBTZXR1cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjbGFzc18xKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5pbnB1dFByb3BzID0ge1xuICAgICAgICAgICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICAvKiogQXV0aCBzdGF0ZSBjaGFuZ2UgaGFuZGxlciBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVBdXRoU3RhdGVDaGFuZ2UgPSBkaXNwYXRjaEF1dGhTdGF0ZUNoYW5nZUV2ZW50O1xuICAgICAgICAvKiogVXNlZCBmb3IgaGVhZGVyIHRleHQgaW4gdG90cCBzZXR1cCBjb21wb25lbnQgKi9cbiAgICAgICAgdGhpcy5oZWFkZXJUZXh0ID0gVHJhbnNsYXRpb25zLlRPVFBfSEVBREVSX1RFWFQ7XG4gICAgICAgIC8qKiBVc2VkIGZvciBjdXN0b21pemluZyB0aGUgaXNzdWVyIHN0cmluZyBpbiB0aGUgcXIgY29kZSBpbWFnZSAqL1xuICAgICAgICB0aGlzLmlzc3VlciA9IFRyYW5zbGF0aW9ucy5UT1RQX0lTU1VFUjtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXR1cE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnFyQ29kZUlucHV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNsYXNzXzEucHJvdG90eXBlLmNvbXBvbmVudFdpbGxMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBXZSBkaWRuJ3QgdXNlIGBAV2F0Y2hgIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGZpcmUgd2hlbiB3ZSBnbyBmcm9tIHJlcXVpcmUtbmV3LXBhc3N3b3JkIHRvIHRvdHAtc2V0dXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGF0IGlzIGJlY2F1c2UgYEF1dGguY29tcGxldGVOZXdQYXNzd29yZGAgb25seSBjaGFuZ2VzIGB1c2VyYCBpbiBwbGFjZSBhbmQgV2F0Y2ggZG9lc24ndCBkZXRlY3QgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogdW5sZXNzIHdlIG1ha2UgYSBjbG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVIdWJMaXN0ZW5lciA9IG9uQXV0aFVJU3RhdGVDaGFuZ2UoZnVuY3Rpb24gKGF1dGhTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoU3RhdGUgPT09IEF1dGhTdGF0ZS5UT1RQU2V0dXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldHVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2V0dXAoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjbGFzc18xLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIdWJMaXN0ZW5lciAmJiB0aGlzLnJlbW92ZUh1Ykxpc3RlbmVyKCk7IC8vIHN0b3AgbGlzdGVuaW5nIHRvIGBvbkF1dGhVSVN0YXRlQ2hhbmdlYFxuICAgIH07XG4gICAgY2xhc3NfMS5wcm90b3R5cGUuYnVpbGRPdHBBdXRoUGF0aCA9IGZ1bmN0aW9uICh1c2VyLCBpc3N1ZXIsIHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gXCJvdHBhdXRoOi8vdG90cC9cIiArIGlzc3VlciArIFwiOlwiICsgdXNlci51c2VybmFtZSArIFwiP3NlY3JldD1cIiArIHNlY3JldEtleSArIFwiJmlzc3Vlcj1cIiArIGlzc3VlcjtcbiAgICB9O1xuICAgIGNsYXNzXzEucHJvdG90eXBlLm9uVE9UUEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnb24gdG90cCBldmVudCcsIGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGV2ZW50ID09PSBTRVRVUF9UT1RQICYmIGRhdGEgPT09IFNVQ0NFU1MpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNoZWNrQ29udGFjdCh1c2VyLCB0aGlzLmhhbmRsZUF1dGhTdGF0ZUNoYW5nZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNsYXNzXzEucHJvdG90eXBlLmhhbmRsZVRvdHBJbnB1dENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnNldHVwTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucXJDb2RlSW5wdXQgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgfTtcbiAgICBjbGFzc18xLnByb3RvdHlwZS5nZW5lcmF0ZVFSQ29kZSA9IGZ1bmN0aW9uIChjb2RlRnJvbVRvdHApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJyb3dzZXIudG9EYXRhVVJMKGNvZGVGcm9tVG90cCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5xckNvZGVJbWFnZVNvdXJjZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hUb2FzdEh1YkV2ZW50KGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNsYXNzXzEucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlZElzc3Vlciwgc2VjcmV0S2V5LCBlcnJvcl8yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHNldHVwIGlzIG9ubHkgcnVuIG9uY2UgYWZ0ZXIgdG90cCBzZXR1cCBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy51c2VyIHx8IHRoaXMudXNlci5jaGFsbGVuZ2VOYW1lICE9PSAnTUZBX1NFVFVQJyB8fCB0aGlzLmxvYWRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZElzc3VlciA9IGVuY29kZVVSSShJMThuLmdldCh0aGlzLmlzc3VlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBdXRoIHx8IHR5cGVvZiBBdXRoLnNldHVwVE9UUCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihOT19BVVRIX01PRFVMRV9GT1VORCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsIDQsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIEF1dGguc2V0dXBUT1RQKHRoaXMudXNlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNyZXRLZXkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlY3JldCBrZXknLCBzZWNyZXRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5idWlsZE90cEF1dGhQYXRoKHRoaXMudXNlciwgZW5jb2RlZElzc3Vlciwgc2VjcmV0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVRUkNvZGUodGhpcy5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hUb2FzdEh1YkV2ZW50KGVycm9yXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKEkxOG4uZ2V0KFRyYW5zbGF0aW9ucy5UT1RQX1NFVFVQX0ZBSUxVUkUpLCBlcnJvcl8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNsYXNzXzEucHJvdG90eXBlLnZlcmlmeVRvdHBUb2tlbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXNlciwgZXJyb3JfMztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucXJDb2RlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIFRPVFAgQ29kZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSB0aGlzLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dGggfHwgdHlwZW9mIEF1dGgudmVyaWZ5VG90cFRva2VuICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBBdXRoLnNldFByZWZlcnJlZE1GQSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihOT19BVVRIX01PRFVMRV9GT1VORCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgNSwgLCA2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBBdXRoLnZlcmlmeVRvdHBUb2tlbih1c2VyLCB0aGlzLnFyQ29kZUlucHV0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIEF1dGguc2V0UHJlZmVycmVkTUZBKHVzZXIsIE1mYU9wdGlvbi5UT1RQKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBNZXNzYWdlID0gSTE4bi5nZXQoVHJhbnNsYXRpb25zLlRPVFBfU1VDQ0VTU19NRVNTQUdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhJMThuLmdldChUcmFuc2xhdGlvbnMuVE9UUF9TVUNDRVNTX01FU1NBR0UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMub25UT1RQRXZlbnQoU0VUVVBfVE9UUCwgU1VDQ0VTUywgdXNlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBNZXNzYWdlID0gSTE4bi5nZXQoVHJhbnNsYXRpb25zLlRPVFBfU0VUVVBfRkFJTFVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3JfMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY2xhc3NfMS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImFtcGxpZnktZm9ybS1zZWN0aW9uXCIsIHsgaGVhZGVyVGV4dDogSTE4bi5nZXQodGhpcy5oZWFkZXJUZXh0KSwgc3VibWl0QnV0dG9uVGV4dDogSTE4bi5nZXQoVHJhbnNsYXRpb25zLlRPVFBfU1VCTUlUX0JVVFRPTl9URVhUKSwgaGFuZGxlU3VibWl0OiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLnZlcmlmeVRvdHBUb2tlbihldmVudCk7IH0sIGxvYWRpbmc6IHRoaXMubG9hZGluZyB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidG90cC1zZXR1cFwiIH0sIHRoaXMucXJDb2RlSW1hZ2VTb3VyY2UgJiYgaChcImltZ1wiLCB7IHNyYzogdGhpcy5xckNvZGVJbWFnZVNvdXJjZSwgYWx0OiBJMThuLmdldChUcmFuc2xhdGlvbnMuUVJfQ09ERV9BTFQpIH0pLCBoKFwiYW1wbGlmeS1mb3JtLWZpZWxkXCIsIHsgbGFiZWw6IEkxOG4uZ2V0KFRyYW5zbGF0aW9ucy5UT1RQX0xBQkVMKSwgaW5wdXRQcm9wczogdGhpcy5pbnB1dFByb3BzLCBmaWVsZElkOiBcInRvdHBDb2RlXCIsIG5hbWU6IFwidG90cENvZGVcIiwgaGFuZGxlSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlVG90cElucHV0Q2hhbmdlKGV2ZW50KTsgfSB9KSkpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gY2xhc3NfMTtcbn0oKSk7XG5BbXBsaWZ5VE9UUFNldHVwLnN0eWxlID0gYW1wbGlmeVRvdHBTZXR1cENzcztcbmV4cG9ydCB7IEFtcGxpZnlSYWRpb0J1dHRvbiBhcyBhbXBsaWZ5X3JhZGlvX2J1dHRvbiwgQW1wbGlmeVRPVFBTZXR1cCBhcyBhbXBsaWZ5X3RvdHBfc2V0dXAgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@aws-amplify/ui-components/dist/esm-es5/amplify-radio-button_2.entry.js\n");

/***/ }),

/***/ "../node_modules/@aws-amplify/ui-components/dist/esm-es5/auth-helpers-63cc23c0.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/@aws-amplify/ui-components/dist/esm-es5/auth-helpers-63cc23c0.js ***!
  \****************************************************************************************/
/*! exports provided: c, h */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return checkContact; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return handleSignIn; });\n/* harmony import */ var _aws_amplify_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aws-amplify/core */ \"../node_modules/@aws-amplify/core/lib-esm/index.js\");\n/* harmony import */ var _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./auth-types-78df304e.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/auth-types-78df304e.js\");\n/* harmony import */ var _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @aws-amplify/auth */ \"../node_modules/@aws-amplify/auth/lib-esm/index.js\");\n/* harmony import */ var _Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Translations-c833f663.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/Translations-c833f663.js\");\n/* harmony import */ var _constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants-d1abe7de.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/constants-d1abe7de.js\");\n/* harmony import */ var _helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers-09e7c279.js */ \"../node_modules/@aws-amplify/ui-components/dist/esm-es5/helpers-09e7c279.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\nvar logger = new _aws_amplify_core__WEBPACK_IMPORTED_MODULE_0__[\"Logger\"]('auth-helpers');\nfunction checkContact(user, handleAuthStateChange) {\n    return __awaiter(this, void 0, void 0, function () {\n        var data, newUser, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!_aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"Auth\"] || typeof _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"Auth\"].verifiedContact !== 'function') {\n                        throw new Error(_constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_4__[\"N\"]);\n                    }\n                    // If `user` is a federated user, we shouldn't call `verifiedContact`\n                    // since `user` isn't `CognitoUser`\n                    if (!isCognitoUser(user)) {\n                        handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].SignedIn, user);\n                        return [2 /*return*/];\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"Auth\"].verifiedContact(user)];\n                case 2:\n                    data = _a.sent();\n                    if (!Object(_aws_amplify_core__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(data.verified) || Object(_aws_amplify_core__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(data.unverified)) {\n                        handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].SignedIn, user);\n                    }\n                    else {\n                        newUser = Object.assign(user, data);\n                        handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].VerifyContact, newUser);\n                    }\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_1 = _a.sent();\n                    Object(_helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_5__[\"a\"])(error_1);\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nvar handleSignIn = function (username, password, handleAuthStateChange) { return __awaiter(void 0, void 0, void 0, function () {\n    var user, error_2;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!_aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"Auth\"] || typeof _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"Auth\"].signIn !== 'function') {\n                    throw new Error(_constants_d1abe7de_js__WEBPACK_IMPORTED_MODULE_4__[\"N\"]);\n                }\n                _a.label = 1;\n            case 1:\n                _a.trys.push([1, 9, , 10]);\n                return [4 /*yield*/, _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"Auth\"].signIn(username, password)];\n            case 2:\n                user = _a.sent();\n                logger.debug(user);\n                if (!(user.challengeName === _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"C\"].SMSMFA || user.challengeName === _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"C\"].SoftwareTokenMFA)) return [3 /*break*/, 3];\n                logger.debug('confirm user with ' + user.challengeName);\n                handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].ConfirmSignIn, user);\n                return [3 /*break*/, 8];\n            case 3:\n                if (!(user.challengeName === _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"C\"].NewPasswordRequired)) return [3 /*break*/, 4];\n                logger.debug('require new password', user.challengeParam);\n                handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].ResetPassword, user);\n                return [3 /*break*/, 8];\n            case 4:\n                if (!(user.challengeName === _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"C\"].MFASetup)) return [3 /*break*/, 5];\n                logger.debug('TOTP setup', user.challengeParam);\n                handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].TOTPSetup, user);\n                return [3 /*break*/, 8];\n            case 5:\n                if (!(user.challengeName === _auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"C\"].CustomChallenge &&\n                    user.challengeParam &&\n                    user.challengeParam.trigger === 'true')) return [3 /*break*/, 6];\n                logger.debug('custom challenge', user.challengeParam);\n                handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].CustomConfirmSignIn, user);\n                return [3 /*break*/, 8];\n            case 6: return [4 /*yield*/, checkContact(user, handleAuthStateChange)];\n            case 7:\n                _a.sent();\n                _a.label = 8;\n            case 8: return [3 /*break*/, 10];\n            case 9:\n                error_2 = _a.sent();\n                if (error_2.code === 'UserNotConfirmedException') {\n                    logger.debug('the user is not confirmed');\n                    handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].ConfirmSignUp, { username: username });\n                }\n                else if (error_2.code === 'PasswordResetRequiredException') {\n                    logger.debug('the user requires a new password');\n                    handleAuthStateChange(_auth_types_78df304e_js__WEBPACK_IMPORTED_MODULE_1__[\"A\"].ForgotPassword, { username: username });\n                }\n                else if (error_2.code === 'InvalidParameterException' && password === '') {\n                    logger.debug('Password cannot be empty');\n                    error_2.message = _Translations_c833f663_js__WEBPACK_IMPORTED_MODULE_3__[\"T\"].EMPTY_PASSWORD;\n                }\n                Object(_helpers_09e7c279_js__WEBPACK_IMPORTED_MODULE_5__[\"a\"])(error_2);\n                return [3 /*break*/, 10];\n            case 10: return [2 /*return*/];\n        }\n    });\n}); };\nvar isCognitoUser = function (user) {\n    return user instanceof _aws_amplify_auth__WEBPACK_IMPORTED_MODULE_2__[\"CognitoUser\"];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9AYXdzLWFtcGxpZnkvdWktY29tcG9uZW50cy9kaXN0L2VzbS1lczUvYXV0aC1oZWxwZXJzLTYzY2MyM2MwLmpzPzEwYjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsU0FBSSxJQUFJLFNBQUk7QUFDL0IsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDb0Q7QUFDMEI7QUFDeEI7QUFDUztBQUNLO0FBQ0Q7QUFDbkUsaUJBQWlCLHdEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBSSxXQUFXLHNEQUFJO0FBQzVDLHdDQUF3Qyx3REFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseURBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzREFBSTtBQUM3QztBQUNBO0FBQ0EseUJBQXlCLGlFQUFPLG1CQUFtQixpRUFBTztBQUMxRCw4Q0FBOEMseURBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlEQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJLFdBQVcsc0RBQUk7QUFDeEMsb0NBQW9DLHdEQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseURBQWEsa0NBQWtDLHlEQUFhO0FBQ3pHO0FBQ0Esc0NBQXNDLHlEQUFTO0FBQy9DO0FBQ0E7QUFDQSw2Q0FBNkMseURBQWE7QUFDMUQ7QUFDQSxzQ0FBc0MseURBQVM7QUFDL0M7QUFDQTtBQUNBLDZDQUE2Qyx5REFBYTtBQUMxRDtBQUNBLHNDQUFzQyx5REFBUztBQUMvQztBQUNBO0FBQ0EsNkNBQTZDLHlEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5REFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5REFBUyxpQkFBaUIscUJBQXFCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5REFBUyxrQkFBa0IscUJBQXFCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyREFBWTtBQUNsRDtBQUNBLGdCQUFnQiw4REFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBRTtBQUNIO0FBQ0EsMkJBQTJCLDZEQUFXO0FBQ3RDO0FBQ2dEIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9AYXdzLWFtcGxpZnkvdWktY29tcG9uZW50cy9kaXN0L2VzbS1lczUvYXV0aC1oZWxwZXJzLTYzY2MyM2MwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IExvZ2dlciwgaXNFbXB0eSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9jb3JlJztcbmltcG9ydCB7IEEgYXMgQXV0aFN0YXRlLCBDIGFzIENoYWxsZW5nZU5hbWUgfSBmcm9tICcuL2F1dGgtdHlwZXMtNzhkZjMwNGUuanMnO1xuaW1wb3J0IHsgQXV0aCwgQ29nbml0b1VzZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvYXV0aCc7XG5pbXBvcnQgeyBUIGFzIFRyYW5zbGF0aW9ucyB9IGZyb20gJy4vVHJhbnNsYXRpb25zLWM4MzNmNjYzLmpzJztcbmltcG9ydCB7IE4gYXMgTk9fQVVUSF9NT0RVTEVfRk9VTkQgfSBmcm9tICcuL2NvbnN0YW50cy1kMWFiZTdkZS5qcyc7XG5pbXBvcnQgeyBhIGFzIGRpc3BhdGNoVG9hc3RIdWJFdmVudCB9IGZyb20gJy4vaGVscGVycy0wOWU3YzI3OS5qcyc7XG52YXIgbG9nZ2VyID0gbmV3IExvZ2dlcignYXV0aC1oZWxwZXJzJyk7XG5mdW5jdGlvbiBjaGVja0NvbnRhY3QodXNlciwgaGFuZGxlQXV0aFN0YXRlQ2hhbmdlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSwgbmV3VXNlciwgZXJyb3JfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBdXRoIHx8IHR5cGVvZiBBdXRoLnZlcmlmaWVkQ29udGFjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE5PX0FVVEhfTU9EVUxFX0ZPVU5EKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBgdXNlcmAgaXMgYSBmZWRlcmF0ZWQgdXNlciwgd2Ugc2hvdWxkbid0IGNhbGwgYHZlcmlmaWVkQ29udGFjdGBcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgYHVzZXJgIGlzbid0IGBDb2duaXRvVXNlcmBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvZ25pdG9Vc2VyKHVzZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBdXRoU3RhdGVDaGFuZ2UoQXV0aFN0YXRlLlNpZ25lZEluLCB1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBBdXRoLnZlcmlmaWVkQ29udGFjdCh1c2VyKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoZGF0YS52ZXJpZmllZCkgfHwgaXNFbXB0eShkYXRhLnVudmVyaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBdXRoU3RhdGVDaGFuZ2UoQXV0aFN0YXRlLlNpZ25lZEluLCB1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VzZXIgPSBPYmplY3QuYXNzaWduKHVzZXIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQXV0aFN0YXRlQ2hhbmdlKEF1dGhTdGF0ZS5WZXJpZnlDb250YWN0LCBuZXdVc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoVG9hc3RIdWJFdmVudChlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxudmFyIGhhbmRsZVNpZ25JbiA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIGhhbmRsZUF1dGhTdGF0ZUNoYW5nZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlciwgZXJyb3JfMjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIUF1dGggfHwgdHlwZW9mIEF1dGguc2lnbkluICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihOT19BVVRIX01PRFVMRV9GT1VORCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDksICwgMTBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBBdXRoLnNpZ25Jbih1c2VybmFtZSwgcGFzc3dvcmQpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB1c2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zyh1c2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoISh1c2VyLmNoYWxsZW5nZU5hbWUgPT09IENoYWxsZW5nZU5hbWUuU01TTUZBIHx8IHVzZXIuY2hhbGxlbmdlTmFtZSA9PT0gQ2hhbGxlbmdlTmFtZS5Tb2Z0d2FyZVRva2VuTUZBKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjb25maXJtIHVzZXIgd2l0aCAnICsgdXNlci5jaGFsbGVuZ2VOYW1lKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVBdXRoU3RhdGVDaGFuZ2UoQXV0aFN0YXRlLkNvbmZpcm1TaWduSW4sIHVzZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICghKHVzZXIuY2hhbGxlbmdlTmFtZSA9PT0gQ2hhbGxlbmdlTmFtZS5OZXdQYXNzd29yZFJlcXVpcmVkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXF1aXJlIG5ldyBwYXNzd29yZCcsIHVzZXIuY2hhbGxlbmdlUGFyYW0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZUF1dGhTdGF0ZUNoYW5nZShBdXRoU3RhdGUuUmVzZXRQYXNzd29yZCwgdXNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKCEodXNlci5jaGFsbGVuZ2VOYW1lID09PSBDaGFsbGVuZ2VOYW1lLk1GQVNldHVwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdUT1RQIHNldHVwJywgdXNlci5jaGFsbGVuZ2VQYXJhbSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQXV0aFN0YXRlQ2hhbmdlKEF1dGhTdGF0ZS5UT1RQU2V0dXAsIHVzZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICghKHVzZXIuY2hhbGxlbmdlTmFtZSA9PT0gQ2hhbGxlbmdlTmFtZS5DdXN0b21DaGFsbGVuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgdXNlci5jaGFsbGVuZ2VQYXJhbSAmJlxuICAgICAgICAgICAgICAgICAgICB1c2VyLmNoYWxsZW5nZVBhcmFtLnRyaWdnZXIgPT09ICd0cnVlJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY3VzdG9tIGNoYWxsZW5nZScsIHVzZXIuY2hhbGxlbmdlUGFyYW0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZUF1dGhTdGF0ZUNoYW5nZShBdXRoU3RhdGUuQ3VzdG9tQ29uZmlybVNpZ25JbiwgdXNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbNCAvKnlpZWxkKi8sIGNoZWNrQ29udGFjdCh1c2VyLCBoYW5kbGVBdXRoU3RhdGVDaGFuZ2UpXTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA4O1xuICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JfMi5jb2RlID09PSAnVXNlck5vdENvbmZpcm1lZEV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCd0aGUgdXNlciBpcyBub3QgY29uZmlybWVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUF1dGhTdGF0ZUNoYW5nZShBdXRoU3RhdGUuQ29uZmlybVNpZ25VcCwgeyB1c2VybmFtZTogdXNlcm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yXzIuY29kZSA9PT0gJ1Bhc3N3b3JkUmVzZXRSZXF1aXJlZEV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCd0aGUgdXNlciByZXF1aXJlcyBhIG5ldyBwYXNzd29yZCcpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVBdXRoU3RhdGVDaGFuZ2UoQXV0aFN0YXRlLkZvcmdvdFBhc3N3b3JkLCB7IHVzZXJuYW1lOiB1c2VybmFtZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3JfMi5jb2RlID09PSAnSW52YWxpZFBhcmFtZXRlckV4Y2VwdGlvbicgJiYgcGFzc3dvcmQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnUGFzc3dvcmQgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXzIubWVzc2FnZSA9IFRyYW5zbGF0aW9ucy5FTVBUWV9QQVNTV09SRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hUb2FzdEh1YkV2ZW50KGVycm9yXzIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgaXNDb2duaXRvVXNlciA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIgaW5zdGFuY2VvZiBDb2duaXRvVXNlcjtcbn07XG5leHBvcnQgeyBjaGVja0NvbnRhY3QgYXMgYywgaGFuZGxlU2lnbkluIGFzIGggfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@aws-amplify/ui-components/dist/esm-es5/auth-helpers-63cc23c0.js\n");

/***/ })

}]);